<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>C-CPP学习笔记（3） | 梦如烟的博客</title><meta name="author" content="梦如烟"><meta name="copyright" content="梦如烟"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="现代C++详解(98, 11, 14, 17)     Part1：课程介绍课程的总体概述一：为什么要出这门课？ 我发现市面上的C++课程基本都停留在C++98阶段，而且基础概念反复重复。 讲的东西对于专业的C++开发不过是入门，还差的很远很远。这就给了很多新手我已经对C++有了基本使用能力的错觉，我已经入门了。 C++可以说是一个大杂烩，它包含c语言面向过程的全部知识，又包括面向对象部分，还包括"><meta property="og:type" content="article"><meta property="og:title" content="C-CPP学习笔记（3）"><meta property="og:url" content="https://moonruyan.github.io/post/5dcb4efe.html"><meta property="og:site_name" content="梦如烟的博客"><meta property="og:description" content="现代C++详解(98, 11, 14, 17)     Part1：课程介绍课程的总体概述一：为什么要出这门课？ 我发现市面上的C++课程基本都停留在C++98阶段，而且基础概念反复重复。 讲的东西对于专业的C++开发不过是入门，还差的很远很远。这就给了很多新手我已经对C++有了基本使用能力的错觉，我已经入门了。 C++可以说是一个大杂烩，它包含c语言面向过程的全部知识，又包括面向对象部分，还包括"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://pic.imgdb.cn/item/66ba1490d9c307b7e9497479.jpg"><meta property="article:published_time" content="2024-08-12T12:50:41.000Z"><meta property="article:modified_time" content="2024-08-12T14:01:30.582Z"><meta property="article:author" content="梦如烟"><meta property="article:tag" content="学习笔记"><meta property="article:tag" content="C&#x2F;C++"><meta property="article:tag" content="基础语法"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://pic.imgdb.cn/item/66ba1490d9c307b7e9497479.jpg"><link rel="shortcut icon" href="https://pic.imgdb.cn/item/66a5d5d0d9c307b7e970da31.png"><link rel="canonical" href="https://moonruyan.github.io/post/5dcb4efe.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="1zTBhNvRNd1Q_yGzIrn_q8c7d9vYuUlJulhdaO4t-XI"><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?ec3f7072f1b046c7091f041f75bbbebb";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"C-CPP学习笔记（3）",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-08-12 22:01:30"}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><link rel="stylesheet" href="https://unpkg.zhimg.com/element-ui@2.15.6/lib/theme-chalk/index.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/custom.css"><div id="myscoll"></div><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload='this.media="all"'><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload='this.media="screen"'><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})</script><link rel="stylesheet" href="/css/progress_bar.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66937eddd9c307b7e97c8c6f.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">63</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://pic.imgdb.cn/item/66ba1490d9c307b7e9497479.jpg)"><nav id="nav"><span id="blog-info"><a href="/" title="梦如烟的博客"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66a5d5d0d9c307b7e970da31.png"><span class="site-name">梦如烟的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C-CPP学习笔记（3）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-08-12T12:50:41.000Z" title="发表于 2024-08-12 20:50:41">2024-08-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-12T14:01:30.582Z" title="更新于 2024-08-12 22:01:30">2024-08-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">19.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>58分钟</span></span><span class="post-meta-separator">|</span><span data-flag-title="C-CPP学习笔记（3）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>现代C++详解(98, 11, 14, 17)</p><h2 id="Part1：课程介绍"><a href="#Part1：课程介绍" class="headerlink" title="Part1：课程介绍"></a>Part1：课程介绍</h2><h4 id="课程的总体概述"><a href="#课程的总体概述" class="headerlink" title="课程的总体概述"></a>课程的总体概述</h4><p><strong>一：为什么要出这门课？</strong></p><p>我发现市面上的C++课程基本都停留在C++98阶段，而且基础概念反复重复。</p><p>讲的东西对于专业的C++开发不过是入门，还差的很远很远。这就给了很多新手我已经对C++有了基本使用能力的错觉，我已经入门了。</p><p>C++可以说是一个大杂烩，它包含c语言面向过程的全部知识，又包括面向对象部分，还包括模板与泛型编程。<strong>很多新手在用c++的语法写c，这是非常不正确的，相当于抛弃了面向对象与模板，这些都是C++的精髓。面向对象与模板才是C++的核心，面向过程更多的是对C语言的一个妥协。</strong></p><p>要学好这三部分，就要把面向过程，面向对象，模板与泛型编程全部学好。</p><ol><li>学好面向过程部分，也就是c语言，需要从编译器的角度出发，每一行代码都要明白内存的变化。</li><li>面向对象部分需要在一定程度上理解内存与编译器，但核心已经不再是内存层面了。</li><li>模板与泛型不怎么需要了解底层，但也是一个非常复杂的模块。可以说，<strong>模板是C++特有的精髓部分，C++几乎所有的库，框架都离不开模板。</strong></li></ol><p>很多新手对于C++的理解太过单一，而且学的太浅了。</p><p>所以我出了这门课，讲的是企业级别的C++，会有一些难度，但这基本就是现代C++的全部知识点了。应该比市面上几乎所有的教程都全，而且很有深度的。</p><p><strong>二：课程内容介绍：企业中，C++11是必学的，后面的会了更好，不会也无所谓。</strong></p><p>这门课总共包含10个部分和三个附录，大致介绍一下：（重要的课程前面都加了*）</p><ol><li>Part1: 课程介绍：没什么实际知识点，就是一个介绍</li><li>Part2: C++的基本特性，属于C++的基础知识，难以被划分到任意一个模块</li><li>Part3 类的特性，C++类的全部常用特性应该就这些，比较全了</li><li>Part4：智能指针，不仅要学习基础知识，使用场景更是核心，很多人根本知道什么时候 该用智能指针。</li><li>Part5：模板与泛型编程。<ol><li><strong>模板很重要，很多人对模板的重视程度不够。</strong></li><li>模板也是泛型编程的基础，泛型编程是一个常用的编程方式，新手对泛型编程可能比较迷糊，觉得不好理解，但它确实功能强大，是C++的核心之一。</li></ol></li><li>Part6：stl库：有了泛型编程的基础，就可以学习stl的实现原理。学习stl不仅要学习使 用方法，实现原理更加重要。可以说，对于stl，懂实现原理和只会使用完全是两个阶段。</li><li>Part7：io库：C++的io功能也很强大，很常用，必会</li><li>Part8：多线程：现代程序基本都是多线程程序，而C++自带的多线程又是现代C++程序实现多线程的主流方式，所以非常重要。</li><li>Part9：异常处理：能否合理的处理异常是衡量一个人水平的重要指标，对于大型程序非 常重要。</li><li>Part10：各种难以归类但很重要的知识点。</li><li>附录一：STL全部的算法</li><li>附录二：STL标准库提供的仿函数</li><li>附录三：STL各种容器的操作</li></ol><p>综上所述：13个部分，除了Part1的课程介绍和三个附录几乎全程重点。所以做了个目录，方便随时查看。</p><p><strong>三：对新手讲一下我推荐的学习C++的路线</strong></p><ol><li>C++语法学到差不多，就去学后面的东西，比如后端开发方向，就可以去学linux开发，网络开发，等有了应用场景，C++的语法就很好学了。比如，异常处理的很多语法单讲非常空洞，但放到具体环境中就很好理解了。我将异常处理放到最后也是因为只有有足够多的代码才可以体现出异常处理的意义。</li><li>一些理论性的东西建议往后放一放，比如操作系统，网络通信的理论部分。对于想做开发的朋友，推荐先实践，后理论。而数据结构，放到最后，它和开发的关系不怎么紧密，数据结构是体系成型的人用来提高的。</li><li>C++一大特点就是没有固定的生态，其他语言，比如java都是有自己对应生态的，直接学对应生态即可，导致了C++的以下特点。<ol><li>C++和底层关系紧密，因为没有固定生态，难以大规模分装，而且C++涉及很多偏向底层的大型项目（比如windows，游戏开发这类特别要求效率的项目），无法牺牲运行效率来换取开发效率。<strong>所以C++非常重视计算机网络和操作系统的理论知识。这也导致C++在很多环境下都是不可替代的。</strong></li><li>语言特性繁多，需要兼容各种使用场景，有很大的历史包袱。</li></ol></li></ol><p><strong>四：这门课就不做ppt了</strong></p><p>有图片就直接粘贴在文档中。ppt更多的是用来展示的，界面华丽，但信息密度太低了，对于这门课，ppt要做需要500页往上，不论我做起来，还是你们看起来，都费劲。</p><p><strong>五：直接开始</strong></p><p>其实时间是很宝贵的，工作的人对此体会应该更加深刻。所以我选择直接把文档写出来，而不是边讲边写文档，这样效率更高，节省时间。</p><h4 id="（-）开发环境介绍"><a href="#（-）开发环境介绍" class="headerlink" title="（*）开发环境介绍"></a>（*）开发环境介绍</h4><p>使用的开发环境就是vs2019，当然vs2017，vs2022也可以，再早就不推荐了，可能有些功能不支持。</p><p>接下来介绍一下vs的基础知识，老手完全可以跳过这一节。</p><h5 id="vs的介绍："><a href="#vs的介绍：" class="headerlink" title="vs的介绍："></a>vs的介绍：</h5><p>vs是一个功能极其强大的集成开发环境，说最强也没有问题，主要的缺点就是不能跨平台，只能在windows上运行。</p><p>而现在C++的主流开发平台是linux，所以很多人就说vs让开发者缺乏对C++执行过程的了解，linux上没有像vs那样强大的集成开发环境，比较分散，开发人员需要自己调度各种资源。</p><h5 id="vs的安装与卸载："><a href="#vs的安装与卸载：" class="headerlink" title="vs的安装与卸载："></a>vs的安装与卸载：</h5><ul><li><ol><li>vs安装：直接去microsoft官网下载就可以了，傻瓜版，我这里演示一下。注意只安装需要的模块就可以了，如果全安装要上百G。</li></ol></li></ul><p><strong>大致演示一下：</strong></p><p>如果没有vs，可以暂停，官网下载一下vs。</p><ul><li><ol><li><strong>（*）vs的卸载</strong>：这里特别注意，vs由微软官方推出，是<strong>直接关系操作系统内核</strong>的，如果乱弄是会玩坏操作系统的，最后就只能重装系统，所以强调一下如何卸载vs。</li></ol></li></ul><p><strong>演示一下：</strong></p><p><strong>其实卸载很简单，主要是不要乱弄，其它任何方式都可能会导致各种遗留问题，最后只能重装系统了。</strong></p><h5 id="vs项目的创建与vs的程序编译过程"><a href="#vs项目的创建与vs的程序编译过程" class="headerlink" title="vs项目的创建与vs的程序编译过程"></a>vs项目的创建与vs的程序编译过程</h5><ul><li><ol><li>vs项目的创建，我用vs2019来演示，C++项目大致分为两种<ol><li>控制台项目：程序在黑窗口运行</li><li>windows桌面应用程序：程序有图形窗口</li></ol></li></ol></li></ul><p>两种程序的区<strong>别就是使用的链接库不同</strong>，C++默认是不支持图形功能的，要实现图形功能，必须调用系统api，所以两种项目必须有两个链接库。</p><p>当然，两种库是可以随时替换的，不一定创建的控制台程序，就一定要当做控制台程序来编写。</p><p>我们这门课用的是<strong>空项目</strong>，能直接体现出C++的语法，没有其它因素的干扰。用的是控制台的链接库。</p><ul><li><ol><li>vs程序的编译过程。很多人说vs的编译过程不利于新人成长，这个说法其实有一定道理，这就和vs的项目目录结构有关了。<ol><li>vs的项目目录是一个解决方案下包括多个项目，vs是以文件组成的项目为最小编译单元的。也就是说vs无法单独编译一个项目中的一个cpp文件，会给新手一定的困扰。</li></ol></li></ol></li></ul><p>这些在老家伙中理所当然，常常被忽略的东西，经常给萌新带来困惑。</p><h5 id="vs的debug功能简介："><a href="#vs的debug功能简介：" class="headerlink" title="vs的debug功能简介："></a>vs的debug功能简介：</h5><p>暂时我们只要会断点功能就可以了，需要知道的是，为了支持调试功能，编译和链 接必须添加很多额外的东西，所以使用debug功能，必须以调试的方式进行编译。</p><h2 id="Part2：C-的基本特性"><a href="#Part2：C-的基本特性" class="headerlink" title="Part2：C++的基本特性"></a>Part2：C++的基本特性</h2><h4 id="（-）程序的执行过程"><a href="#（-）程序的执行过程" class="headerlink" title="（*）程序的执行过程"></a>（*）程序的执行过程</h4><p>程序被执行后就被称为一个进程，一个进程可以被划分为很多区域，这门课我们只需要理解以下的四个区就可以了。</p><ol><li><strong>代码区与常量区</strong>：进程按照代码区的代码执行，真正的常量也存储在这里，比如“abc”字符串，“1”，“88”等数字。这些是真正的常量。再看一下const关键字。const只不过是让编译器将变量视为常量罢了，和真正的常量有本质上的区别。</li><li><strong>栈区</strong>：函数的执行所需的空间，注意，当函数执行完毕，函数对应的栈内存全部销毁。</li><li><strong>堆区</strong>：进程用来灵活分配内存的地方，只有手动释放时才会销毁内存。</li><li><strong>静态变量区</strong>：用来存储静态变量与全局变量的区域<ol><li>静态变量：我们常常需要一些局部作用范围，生命周期却很长的变量</li><li>全局变量：重要性就不必说了，在c语言程序中经常用到，但在C++中不推荐使用，因为会破坏封装性。</li></ol></li></ol><p>具体的存储方式如图所示：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66ba0138d9c307b7e92e27d4.jpg" alt="code"></p><p>接下来用代码演示一下这几个区域。</p><p>堆区和栈区，是程序运行的主要地方。我们用一个最简单的程序来显示栈的用途。</p><p><strong>代码演示：</strong></p><p>至于堆区，主要意义在于灵活的生命周期，同样是刚才那个例子。</p><p>如果需要创建的对象有几十M，每次调用函数都需要创建一个这么大的对象，再复制到对应的容器中，那就太过耗费内存了。而且栈内存非常的小，通常不超过8M。</p><p>而使用堆内存，每调用一次函数就可以在堆内存中创建一个对象，容器中只要存储指针就可以了，极大的提高了程序效率。</p><p><strong>代码演示：</strong></p><p>而静态变量区：</p><p>有很多情况下，我们需要作用范围局限在函数之内，但生命周期却很长的变量，比如统计一个函数被调用的次数。</p><p>总结：栈区是函数执行的区域，堆区是函数内灵活分配内存的地方，二者缺一不可。</p><p>有很多人问为什么不能只在栈上运行程序，因为当函数运行结束时，栈是要销毁的，其上分配的内存全部失效。</p><p>也不能只在堆上运行程序，因为堆的唯一寻址方式就是指针，如果没有栈，根本无法使用堆。</p><p>提一下：栈区远远小于堆区，一般不超过8M，所以主要的内容都在对堆区上。堆区很大，虚拟内存剩下的都是堆区。</p><p><strong>注意：这节课对内存的划分比较粗糙，但新手理解到这里完全没有问题，这门课也够用了。</strong></p><p>程序执行的细节，还有剩下的区域是干什么的，我打算出一门叫做C++内存详解的课程，里面会详细讲解。包括pe文件头，内核区等。</p><h4 id="（-）new关键字及内存泄露"><a href="#（-）new关键字及内存泄露" class="headerlink" title="（*）new关键字及内存泄露"></a>（*）new关键字及内存泄露</h4><ol><li>new关键字是C++用来动态分配内存的主要方式。</li></ol><p><strong>代码演示：</strong></p><p>new可以直接分配单个变量的内存，也可以分配数组。</p><p>在分配单个对象的内存时。</p><p>当对象是普通变量时，可以分配对应的内存</p><p>当对象是类对象时，会调用构造函数，如果没有对应的构造函数，就会报错。</p><p>在分配数组对象内存时：</p><p>对于普通变量：可以使用“（）”将所有对象全部初始化为0。</p><p>对于类对象，有没有“（）”都一样，均使用默认构造函数，如果没有默认构造函数就会报错。</p><ol><li>内存泄露介绍：内存泄露是经常出现的常见bug。</li></ol><p><strong>代码演示：</strong></p><p>内存泄露会导致堆内存的逐渐被占用，最终内存用完程序崩溃。常见的情况就是项目测试没问题，上线几天就炸了。然后就会非常麻烦，排查困难，损失很大。</p><p><strong>内存泄露是最严重的错误之一，程序不怕报错，就怕一开始运行的好好的，突然就出现了莫名其妙的错误。</strong></p><p>这句话也引出了后面的两个部分。</p><p><strong>Part4的智能指针</strong>可以非常好的避免内存泄露的问题。</p><p><strong>Part9的异常处理</strong>部分可以恰当的处理程序出现的异常，让程序有错误就立马处理，或直接终止进程，或忽略，不要让异常莫名其妙。这是程序设计的重要理念。</p><h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>C++经常需要多个团队合作来完成大型项目。多个团队就常常出现起名重复的问题，C++就提供了命名空间来解决这个问题。</p><p>比如团队A和团队B都需要定义一个叫做Test的类。</p><p><strong>这里用代码简单演示：</strong></p><p>顺便提两点：<br>命名空间的实现原理，C++最后都要转化为C来执行程序。在namespace A中定义的Test类，其实全名是A::Test。</p><p>C++所有特有的库（指c没有的库）,都使用了std的命名空间。比如最常用的iostream。</p><p>using关键字设计的目的之一就是为了简化命名空间的。using关键字在命名空间方面主要有两种用法。</p><ol><li>using 命名空间：：变量名。这样以后使用此变量时只要使用变量名就可以了。举个例子。</li><li>using namspce 命名空间。这样，每一个变量都会在该命名空间中寻找。举个例子。</li></ol><p><strong>（*）所以，头文件中一定不能使用using关键字。会导致命名空间的污染。</strong></p><p><strong>还是用刚才的代码演示。</strong></p><h4 id="（-）C-的标准输入输出简介"><a href="#（-）C-的标准输入输出简介" class="headerlink" title="（*）C++的标准输入输出简介"></a>（*）C++的标准输入输出简介</h4><p>输入输出简单来说就是数据在输入设备，内存，硬盘，输出设备之间移动的过程。</p><p>c语言设定了很多不相关的函数还实现这些过程。</p><p>比如printf就是让数据从内存到显示屏（显示屏就是输出设备）。scanf就是让数据从键盘（键盘是输入设备）到内存。此外还有从内存到磁盘的文件操作函数。</p><p>c语言的函数虽然简单方便，但彼此之间没有关联。C++有了继承功能，可以让子类与父类之间有关联性，极大的提高各种输入输出功能之间的耦合性。</p><p>于是C++用继承功能重写了输入输出功能，这就是io库，io库引入了“流”的概念，数据从一个地方到另一个地方，原本地方的数据就没了，叫做流很贴切。</p><p>io库是一个很大的部分，但现阶段我们只要会使用输入输出流，cout和cin就可以了。</p><p>cout可以让数据从内存流到输出设备，cin可以让数据从输入设备流到内存。</p><p><strong>代码演示：</strong></p><p><strong>等到Part7，io库会详细讲解。</strong></p><h4 id="4-5-const关键字介绍"><a href="#4-5-const关键字介绍" class="headerlink" title="4.5. const关键字介绍"></a>4.5. const关键字介绍</h4><p><strong>首先说一下：这一课是后面加的，原先的目录上没有这一课，所以就叫做4.5课了。后面觉得讲一下const关键字还是很有意义的。很多人对const修饰的变量和真正的常量分不清。</strong></p><p>const关键字介绍：const是让编译期将变量视为常量，用const修饰的变量和真正的常量有本质的区别。</p><p>代码演示：</p><ol><li>真正的常量存储在常量区或代码区，比如“abcdefg”这个字符串就存储在常量区，而“3”，“100”这些数字就存储在代码区中，这些都是真正的常量，无法用任何方式修改。</li><li>const修饰的变量仍然存储在堆区或栈区中，从内存分布的角度讲，和普通变量没有区别。const修饰的变量并非不可更改的，C++本身就提供了mutable关键字（这个关键字在Part3就会讲的）用来修改const修饰的变量，从汇编的角度讲，const修饰的变量也是可以修改的。</li></ol><h4 id="（-）-auto关键字的使用"><a href="#（-）-auto关键字的使用" class="headerlink" title="（**） auto关键字的使用"></a>（**） auto关键字的使用</h4><p>auto是C++11新加入的关键字，就是为了简化一些写法。</p><p><strong>代码演示：</strong></p><p>使用auto推断类型确实简单方便，但有个基本要求，就是在使用auto时清楚的知道编译器会给auto推断出什么类型。</p><p>为了学习auto的类型推断，我使用一个boost库来确定变量的具体类型。至于boost是什么，这里就不介绍了，大家可以去百度一下。</p><p>boost库的类型推断更加灵活方便，直观。而且Part10讲万能引用，完美转发时boost也是必须使用的，所以这里就提前使用boost了。其实这里采用vs默认提供的类型提示功能也可以。</p><p>首先下载，安装boost库，就直接视频演示了，不在文档中描述了。</p><p>这两个命令执行完毕，boost库也就编译好了。boost库很大，可以选择编译自己想要的模块，我就直接全部编译了。boost是很复杂的，不是几句话能说清楚，要深入理解可以去官网学习。</p><p>两个库，每一个编译都需要十几分钟，所以视频就暂停了。</p><p>这两个命令我放在一个boostCommand.txt的文件中，这个文件已经放在最终的文件包中。</p><p>auto有几个点需要注意：</p><p><strong>有些不好理解，可以多看几遍，或者带着问题学习下面的课程，Part2的所有知识都是反复用到的。</strong></p><ol><li>auto只能推断出类型，引用不是类型，所以auto无法推断出引用，要使用引用只能自己加引用符号。</li></ol><p><strong>代码演示：</strong></p><ol><li>auto关键字在推断引用的类型时：会直接将引用替换为引用指向的对象。其实引用一直是这样的，引用不是对象，任何使用引用的地方都可以直接替换成引用指向的对象。</li></ol><p><strong>代码演示：</strong></p><ol><li>auto关键字在推断类型时，如果没有引用符号，会忽略值类型的const修饰，而保留修饰指向对象的const，典型的就是指针。<strong>可能有些不好理解，看看代码就好说了。3和4的主要作用对象就是指针。</strong></li></ol><p><strong>代码演示：</strong></p><ol><li>auto关键字在推断类型时，如果有了引用符号，那么值类型的const和修饰指向对象的const都会保留。</li></ol><p><strong>代码演示：</strong></p><p>其实3，4为什么会出现这种情况，因为在传递值时，修改这个值并不会对原有的值造成影响。而传递引用时，修改这个值会直接对原有的值造成影响。</p><p>确实不太好理解，尤其是基础不扎实的人。不懂了可以多问问我。</p><ol><li>当然，我们可以在前面加上const，这样永远都有const的含义。</li></ol><p><strong>代码演示：</strong></p><ol><li>auto不会影响编译速度，甚至会加快编译速度。因为编译器在处理XX a = b时，当XX是传统类型时，编译期需要检查b的类型是否可以转化为XX。当XX为auto时，编译期可以按照b的类型直接给定变量a的类型，所以效率相差不大，甚至反而还有提升。</li><li>（*）最重要的一点，就是auto不要滥用，对于一些自己不明确的地方不要乱用auto，否则很可能出现事与愿违的结果，使用类型应该安全为先。</li><li>（*）auto主要用在与模板相关的代码中，一些简单的变量使用模板常常导致可读性下降，经验不足还会导致安全性问题。</li></ol><p><strong>注意：auto的用法这里大致了解就可以了，Part10会有一节详细的讲auto的类型推断的，这节课是没有涉及右值引用的，那里会将这一部分。而且现在没有讲模板，难以讲出auto关键字的主要用法。</strong></p><h4 id="（-）静态变量，指针和引用"><a href="#（-）静态变量，指针和引用" class="headerlink" title="（*）静态变量，指针和引用"></a>（*）静态变量，指针和引用</h4><p>变量的存储位置有三种，分别是静态变量区，栈区，堆区。</p><p>静态变量区在编译时就已经确定地址，存储全局变量与静态变量。</p><p><strong>代码演示：</strong></p><p>指针都是存储在栈上或堆上，不管在栈上还是堆上，都一定有一个地址。</p><p>本质上说，指针和普通变量没有区别。</p><p>在32位系统中，int变量和指针都是32位。指针必须和“&amp;”，“*”这两个符号一起使用才有意义。</p><p>&amp;a代表的a这个变量的地址，a代表的a对应地址存储的值，*a代表对应地址存储的值作为地址对应的值，这句话可能不好理解。</p><p><strong>代码演示：</strong></p><p>所以指针才可以灵活的操作内存，但这也带来了严重的副作用，比如指针加加减减就可以操作内存，所以引用被发明了，引用就是作用阉割的指针（可以视为“类型*const”，所以引用必须上来就赋初值，不能设置为空），编译器不将其视作对象，操作引用相当于操作引用指向的对象。<strong>也就从根本是杜绝了引用篡改内存的能力。</strong></p><p><strong>新手如果不懂内存，就直接将引用视为指向对象的别名就可以了。</strong></p><p><strong>要真正理解指针，引用是需要学习c语言对应汇编的，只要懂了汇编，一目了然。不懂汇编就只能这样理解了。</strong></p><h4 id="（-）左值，右值，左值引用，右值引用"><a href="#（-）左值，右值，左值引用，右值引用" class="headerlink" title="（**）左值，右值，左值引用，右值引用"></a>（**）左值，右值，左值引用，右值引用</h4><p><strong>首先说一点：在学这节课时不要去想左值，右值，左值引用，右值引用有什么意义。以后会反复使用的，这些概念都很重要。</strong></p><h5 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h5><p>左值右值从C++11开始就是一个很重要的概念了，但想要真正理解左值，右值不是一件容易的事。</p><p>尤其新人要彻底理解左值右值就更加困难了，所以我推荐新手将这些概念死死记住，带着疑惑学习下面的课程，积累的多了，自然就明白了。后面左值，右值的概念会被反复提及。</p><p><strong>C++任何一个对象要么是左值，要么是右值。</strong></p><p>比如int i = 10，i和10都是对象</p><p><strong>左值：拥有地址属性的对象就叫左值，</strong>左值来源于c语言的说法，能放在“=”左面的就是左值，注意，左值也可以放在“=”右面。</p><p><strong>右值：不是左值的对象就是右值。或者说无法操作地址的对象就叫做右值。</strong>一般来说，判断一个对象是否为右值，就看它是不是左值，有没有地址属性，不是左值，那就是右值。</p><p><strong>比如临时对象，就都是右值，临时对象的地址属性无法使用。</strong></p><p><strong>注意：左值也可以放在“=”右面，但右值绝对不可以放在等号左面</strong></p><p><strong>接下来就是大量举例了，说明那些是左值，哪些是右值。</strong></p><p><strong>代码演示。</strong></p><h5 id="引用的分类"><a href="#引用的分类" class="headerlink" title="引用的分类"></a>引用的分类</h5><ul><li><ol><li>普通左值引用：就是一个对象的别名，只能绑定左值，无法绑定常量对象。</li><li>const左值引用：可以对常量起别名，可以绑定左值和右值。</li><li><strong>右值引用</strong>（暂时不要去管右值引用有什么用，只要记住语法就可以了，实际用途下一课就会讲到）：只能绑定右值的引用。</li><li>万能引用：这节课不讲，等到part10涉及模板时再讲，这是一个很重要，但需要模板等基础的概念。</li></ol></li></ul><p><strong>代码演示：</strong></p><h4 id="（-）move函数，临时对象"><a href="#（-）move函数，临时对象" class="headerlink" title="（**）move函数，临时对象"></a>（**）move函数，临时对象</h4><p><strong>首先说一点：这节课是第7课的继续，是对右值基础的补充，右值的具体应用要等到Part3的移动语义那里才能完全体现。</strong></p><h5 id="move函数："><a href="#move函数：" class="headerlink" title="move函数："></a>move函数：</h5><ul><li><ol><li>右值看重对象的值而不考虑地址，move函数可以对一个左值使用，使操作系统不再在意其地址属性，将其完全视作一个右值。</li><li>move函数让操作的对象失去了地址属性，<strong>所以我们有义务保证以后不再使用该变量的地址属性，简单来说就是不再使用该变量，因为左值对象的地址是其使用时无法绕过的属性。</strong></li></ol></li></ul><p><strong>代码演示：</strong></p><p><strong>move函数的具体意义现阶段无需在意，Part3讲移动语义时会体现move函数意义的。</strong></p><h5 id="临时对象："><a href="#临时对象：" class="headerlink" title="临时对象："></a>临时对象：</h5><p><strong>右值都是不体现地址的对象。那么，还有什么能比临时对象更加没有地址属性呢？右值引用主要负责处理的就是临时对象。</strong></p><p>程序执行时生成的中间对象就是临时对象，注意，所有的临时对象都是右值对象，因为临时对象产生后很快就可能被销毁，使用的是它的值属性。</p><p><strong>代码演示：</strong></p><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>右值和右值引用这里只介绍语法，等到Part3的第11课，会学习移动构造，右值引用会真正体现出提高程序性效率的功能。</p><h4 id="（-）可调用对象"><a href="#（-）可调用对象" class="headerlink" title="（**）可调用对象"></a>（**）可调用对象</h4><p>如果一个对象可以使用调用运算符“()”，()里面可以放参数，这个对象就是可调用对象。</p><p>（*）<strong>注意：可调用对象的概念新手只要记住就可以了，后面会反复用到，这个概念很重要。</strong></p><p>可调用对象的分类：</p><h5 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h5><p>函数自然可以调用()运算符，是最典型的可调用对象。</p><h5 id="仿函数："><a href="#仿函数：" class="headerlink" title="仿函数："></a>仿函数：</h5><p>具有operator()函数的类对象（<strong>知道有这么个东西就可以了，具体实现过程Part3会讲</strong>），此时类对象可以当做函数使用，因此称为仿函数。</p><h5 id="lambda表达式："><a href="#lambda表达式：" class="headerlink" title="lambda表达式："></a>lambda表达式：</h5><p>就是匿名函数，普通的函数在使用前需要找个地方将这个函数定义，于是C++提供了lambda表达式，需要函数时直接在需要的地方写一个lambda表达式，省去了定义函数的过程，增加开发效率。</p><p><strong>注意：lambda表达式很重要，现代C++程序中，lambda表达式是大量使用的。</strong></p><p><strong>lambda表达式的格式：</strong>最少是“[] {}”，完整的格式为“[] () -&gt;ret {}”。</p><p>代码演示：</p><p>lambda各个组件介绍</p><ol><li>[]代表捕获列表：表示lambda表达式可以访问前文的哪些变量。<ol><li>[]表示不捕获任何变量。</li><li>[=]：表示按值捕获所有变量。</li><li>[&amp;]：表示按照引用捕获所有变量。</li></ol></li></ol><p>=，&amp;也可以混合使用，比如</p><ul><li><ol><li>[=, &amp;i]：表示变量i用引用传递，除i的所有变量用值传递。</li><li>[&amp;, i]：表示变量i用值传递，除i的所有变量用引用传递。</li></ol></li></ul><p>当然，也可以捕获单独的变量</p><ul><li><ol><li>[i]：表示以值传递的形式捕获i</li><li>[&amp;i]：表示以引用传递的方式捕获i</li></ol></li></ul><ol><li>()代表lambda表达式的参数，函数有参数，lambda自然也有。</li><li>-&gt;ret表示指定lambda的返回值，如果不指定，lambda表达式也会推断出一个返回值的。</li><li>{}就是函数体了，和普通函数的函数体功能完全相同。</li></ol><p>l<strong>ambda后面会广泛使用，现在只要理解基础就可以了。</strong></p><p>C++的可调用对象主要就这三个，当然，这三个也可以衍生出很多写法。</p><p>最常见的就是函数指针，函数指针的本质就是利用指针调用函数，本质还是函数。</p><p>函数指针要细分也可以分为指向类成员函数的指针，指向普通函数的指针。</p><p>这些在这里就不演示了。</p><h2 id="Part3：类"><a href="#Part3：类" class="headerlink" title="Part3：类"></a>Part3：类</h2><p><strong>首先提一下：类的权限修饰就不讲了，相信大家对于这个已经很了解了，如果不了解，就百度一下吧，非常简单，易懂，直接问我也可以。</strong></p><h4 id="（-）类介绍，构造函数，析构函数"><a href="#（-）类介绍，构造函数，析构函数" class="headerlink" title="（*）类介绍，构造函数，析构函数"></a>（*）类介绍，构造函数，析构函数</h4><ol><li>类介绍：<ol><li>面试的时候经常会听到一个问题，谈一下对面向对象和面向过程的理解。我来说一下我对这两个概念的理解<ol><li>面向对象和面向过程是一个相对的概念。</li><li>面向过程是按照计算机的工作逻辑来编码的方式，最典型的面向过程的语言就是c语言了，c语言直接对应汇编，汇编又对应电路。</li><li>面向对象则是按照人类的思维来编码的一种方式，C++就完全支持面向对象功能，可以按照人类的思维来处理问题。</li><li>举个例子，要把大象装冰箱，按照人类的思路自然是分三步，打开冰箱，将大象装进去，关上冰箱。</li></ol></li></ol></li></ol><p>要实现这三步，我们就要首先有人，冰箱这两个对象。人有给冰箱发指令的能 力，冰箱有能够接受指令并打开或关闭门的能力。</p><p>但是从计算机的角度讲，计算机只能定义一个叫做人和冰箱的结构体。人有手这个部位，冰箱有门这个部位。然后从天而降一个函数，是这个函数让手打开了冰箱，又是另一个函数让大象进去，再是另一个函数让冰箱门关上。</p><p>从开发者的角度讲，面向对象显然更利于程序设计。用面色过程的开发方式，程序一旦大了，各种从天而降的函数会非常繁琐，一些用纯c写的大型程序，实际上也是模拟了面向对象的方式。</p><p>那么，如何用面向过程的c语言模拟出面向对象的能力呢？类就诞生了，在类中可以定义专属于类的函数，让类有了自己的动作。回到那个例子，人的类有了让冰箱开门的能力，冰箱有了让人打开的能力，不再需要天降神秘力量了。</p><p><strong>总结：到现在，大家应该可以理解类的重要性了吧，这是面向对象的基石，也可以说是所有现代程序的基石。</strong></p><ol><li>构造函数：<br>类再怎么吹，它也是通过面向过程的机器实现的，类相当于定义了一个新类型，该类型生成在堆或栈上的对象时内存排布和c语言相同。但是c++规定，C++有在类对象创建时就在对应内存将数据初始化的能力，这就是构造函数。</li></ol><p><strong>用excel表格演示一下：</strong></p><p>构造函数有以下类型。</p><ol><li>普通构造函数：写法代码演示</li><li>复制构造函数：用另一个对象来初始化对象对应的内存，代码演示</li><li>移动构造函数：也是用另一个对象来初始化对象，具体内容会在Part3第13节详细讲解。</li><li>默认构造函数：当类没有任何构造函数时，编译期会为该类生成一个默认的的构造函数，在最普通的类中，默认构造函数什么都没做，对象对应的内存没有被初始化。</li></ol><p><strong>代码演示。</strong></p><p>总结：构造函数就是C++提供的<strong>必须有的</strong>在对象创建时初始化对象的方法，（默认的什么都不做也是一种初始化的方式）</p><ol><li>析构函数：</li></ol><p>析构函数介绍：当类对象被销毁时，就会调用析构函数。栈上对象的销毁时机就是函数栈销毁时，代码演示。堆上的对象销毁时机就是该堆内存被手动释放时，如果用new申请的这块堆内存，那调用delete销毁这块内存时就会调用析构函数。</p><p><strong>代码演示：</strong></p><p>总结，当类对象销毁时有一些我们必须手动操作的步骤时，析构函数就派上了用场。所以，几乎所有的类我们都要写构造函数，析构函数却未必需要。</p><h4 id="（-）this，常成员函数与常对象"><a href="#（-）this，常成员函数与常对象" class="headerlink" title="（*）this，常成员函数与常对象"></a>（*）this，常成员函数与常对象</h4><ol><li>this关键字：<ol><li>this是什么：<ol><li>编译器将this解释为指向函数所作用的对象的指针，这句话新手有些不好理解，用代码演示一下就好说了。C++类的本质就是C语言的结构体外加几个类外的函数，C++最后都要转化为C语言来实现，类外的函数就是通过this来指向这个类的。</li></ol></li></ol></li></ol><p><strong>代码演示：</strong></p><ul><li><ul><li><ol><li>当然，这么说并非完全准确，this是一个关键字，只是我们将它当做指针理解罢了。</li></ol></li></ul></li></ul><p>this有很多功能是单纯的指针无法满足的。比如每个类函数的参数根本没有名 叫this的指针。这不过是编译器赋予的功能罢了。</p><ol><li>常成员函数和常对象</li></ol><p><strong>首先说一下：常成员函数和常对象很多人并不在意，确实，都写普通变量也可以。但是，我还是要提一点，在大型程序中，尽量加上const关键字可以减少很多不必要的错误。</strong></p><p><strong>这一点，开发过大型程序的人应该深有体会，没开发过大型程序的人也不必在意，记住多用const，这是一个很好的习惯。</strong></p><ul><li><ol><li>const关键字含义：普通的const在Part2的第4.5节就已经讲完了。所以这里说一下<strong>常成员函数和常对象。</strong></li></ol></li></ul><p>常成员函数就是无法修改成员变量的函数。可以理解为将this指针指向对象用const修饰的函数。</p><p>常对象就是用const修饰的对象，定义好之后就再也不需要更改成员变量的值了。常对象在大型程序中还是很有意义的。</p><p><strong>代码演示：</strong></p><ul><li><ol><li>常成员函数注意事项：</li></ol></li></ul><p>因为类的成员函数已经将this指针省略了，只能在函数后面加const关键字来实现无法修改类成员变量的功能了</p><ul><li><ul><li><ol><li>注意：常函数无法调用了普通函数，否则常函数的这个“常”字还有什么意义。</li><li><strong>成员函数能写作常成员函数就尽量写作常成员函数，可以减少出错几率。</strong></li><li>同名的常成员函数和普通成员函数是可以重载的，常量对象会优先调用常成员函数，普通对象会优先调用普通成员函数</li></ol></li></ul></li></ul><p><strong>代码演示。</strong></p><ul><li><ol><li>常对象注意事项：<ol><li>常对象不能调用普通函数，这一点之前其实已经讲过了。</li><li>常函数在大型程序中真的很重要，很多时候我们都需要创建好就不再改变的对象。</li></ol></li><li>总结：<strong>再说一遍，毕竟重要的话说三遍吗！常成员函数和常对象要多用，这真的是一个非常好的习惯，写大项目可以少出很多bug，</strong></li></ol></li></ul><h4 id="inline，mutable，default，delete"><a href="#inline，mutable，default，delete" class="headerlink" title="inline，mutable，default，delete"></a>inline，mutable，default，delete</h4><p><strong>这一节是Part3少有的不带“*”的课程。</strong></p><p><strong>inline和mutable只要知道有这么个关键字就可以了。</strong></p><p><strong>default和delete关键字是需要掌握的，但是比较简单，也就放在这里了。</strong></p><ol><li>inline关键字<ol><li>inline关键字的有什么作用：<ol><li>在函数声明或定义中函数返回类型前加上关键字inline就可以把函数指定为内联函数。关键字inline必须与函数定义放在一起才能使函数成为内联，仅仅将inline放在函数声明前不起任何作用。</li><li>内联函数的作用，普通函数在调用时需要给函数分配栈空间以供函数执行，压栈等操作会影响成员运行效率，于是C++提供了内联函数将函数体放到需要调用函数的地方，用空间换效率。</li></ol></li><li>i<strong>nline关键字的注意事项：inline关键字只是一个建议，开发者建议编译器将成员函数当做内联函数，一般适合搞内联的情况编译器都会采纳建议。</strong></li><li>Inline关键字的总结。使用inline关键字就是一种提高效率，但加大编译后文件大小的方式，<strong>现在随着硬件性能的提高，inline关键字用的越来越少了</strong>。</li></ol></li><li>mutable关键字<ol><li>mutable关键字的作用：<ol><li>Mutable意为可变的，与const相对，被mutable修饰的成员变量，永远处于可变的状态，即便处于一个常函数中，该变量也可以被更改。</li></ol></li></ol></li></ol><p><strong>代码演示：</strong></p><p><strong>这个关键字在现代C++中使用情况并不多，一般来说只有在统计函数调用次数时才会用到。</strong></p><ul><li><ol><li>mutable关键字的注意事项<ol><li>mutable是一种万不得已的写法，一个程序不得不使用mutable关键字时，可以认为这部分程序是一个糟糕的设计。</li><li>mutable不能修饰静态成员变量和常成员变量。</li></ol></li><li>总结：mutable关键字是一种没有办法的办法，设计时应该尽量避免，只有在统计函数调用次数这类情况下才推荐使用。这个关键字也称不上是重点。</li></ol></li></ul><ol><li>default关键字<ol><li>default关键字的作用：default关键字的作用很简单。<ol><li>在编译时不会生成默认构造函数时便于书写。</li><li>也可以对<strong>默认复制构造函数，默认的赋值运算符和默认的析构函数</strong>使用，表示使用的是系统默认提供的函数，这样可以使代码更加明显。</li><li><strong>现代C++中，哪怕没有构造函数，也推荐将构造函数用default关键字标记，可以让代码看起来更加直观，方便。</strong></li></ol></li></ol></li></ol><p><strong>代码演示：</strong></p><p><strong>总结：default关键字还是推荐使用的，在现代C++代码中，如果需要使用一些默认的函数，推荐用default标记出来。</strong></p><ol><li>delete关键字<ol><li>Delete关键字的作用：C++会为程序生成默认构造函数，默认复制构造函数，默认重载赋值运算符（重载部分会详细讲解）。</li></ol></li></ol><p>在很多情况下，我们并不希望这些默认的函数被生成，在C++11以前，只能有将此 函数声明为私有函数或是将函数只声明不定义两种方式。</p><p>C++11于是提供了delete关键字，只要在函数最后加上“=delete”就可以明确告诉 编译期不要默认生成该函数。</p><p><strong>代码演示：</strong></p><p><strong>总结：delete关键字还是推荐使用的，在现代C++代码中，如果不希望一些函数默认生成，就用delete表示，这个功能还是很有用的，比如在单例模式中，</strong></p><h4 id="友元类与友元函数"><a href="#友元类与友元函数" class="headerlink" title="友元类与友元函数"></a>友元类与友元函数</h4><p><strong>抱歉：我在录视频时看错课数了，这应该是第4课的，所以这节课就又当第4课，又当第5课了，下一课还是第六课：</strong></p><ol><li>友元的介绍：友元就是可以让另一个类或函数访问私有成员的简单写法。</li></ol><p><strong>代码演示：</strong></p><ol><li>注意：<ol><li>友元会破坏封装性，一般不推荐使用，所带来的方便写几个接口函数就解决了。</li><li><strong>(*)某些运算符的重载必须用到友元的功能，这才是友元的真正用途，具体怎么重载下一课就会讲。</strong></li></ol></li><li>总结：<strong>友元平常并不推荐使用，新手不要再纠结友元的语法了，只要可以用友元写出必须用友元的重载运算符就可以了，重载运算符下一课就会讲。</strong></li></ol><h4 id="（-）重载运算符"><a href="#（-）重载运算符" class="headerlink" title="（**）重载运算符"></a>（**）重载运算符</h4><p>重载运算符在整个C++中拥有非常重要的地位，这一节非常重要。</p><ol><li>重载运算符的作用：<ol><li>很多时候我们想让类对象也能像基础类型的对象一样进行作基础操作，比如“+”，“-”，“*”，“\”，也可以使用某些运算符“=”，“()”，“[]”,“&lt;&lt;”，“&gt;&gt;”。但是一般的类即使编译器可以识别这些运算符，类对象也无法对这些运算符做出应对，我们必须对类对象定义处理这些运算符的方式。</li><li>C++提供了定义这些行为的方式，就是“operator 运算符”来定义运算符的行为，operator是一个关键字，告诉编译器我要重载运算符了。</li></ol></li><li>注意：<ol><li>我们只能重载C++已有的运算符，所有无法将“**”这个运算符定义为指数的形式，因为C++根本没有“**”这个运算符。</li><li>C++重载运算符不能改变运算符的元数，“元数”这个概念就是指一个运算符对应的对象数量，比如“+”必须为“a + b”，也就是说“+”必须有两个对象，那么“+”就是二元运算符。比如“++”运算符，必须写为“a++”，也就是一元运算符。</li></ol></li><li>重载运算符举例</li></ol><p><strong>以下全部用代码演示：</strong></p><ul><li><ol><li>一元运算符重载<ol><li>“++”，“--”,</li><li>“[]”</li><li>“()”</li><li>“&lt;&lt;”，“&gt;&gt;”</li></ol></li><li>二元运算符重载<ol><li>“+”，“-”，“*”，“/”</li><li>“=”，</li><li>“&gt;”，“&lt;”，“==”</li></ol></li></ol></li></ul><p>至于唯一的三元运算符“?:”，不能重载</p><ul><li><ol><li>类类型转化运算符：“operator 类型”</li><li>特殊的运算符：new，delete，new[]，delete[]</li></ol></li></ul><p>注意：“=”类会默认进行重载，如果不需要可以用“delete关键字进行修饰”。</p><p><strong>总结：重载运算符非常重要，C++类中几乎都要定义各种各种的重载运算符。</strong></p><h4 id="（-）普通继承及其实现原理"><a href="#（-）普通继承及其实现原理" class="headerlink" title="（*）普通继承及其实现原理"></a>（*）普通继承及其实现原理</h4><p><strong>C++面向对象的三大特性：分装，继承，多态。分装就是类的权限管理，很简单，就不讲了。继承这节课讲，继承很重要，有些地方也是需要重点理解的。</strong></p><ol><li>C++继承介绍：C++非继承的类相互是没有关联性的，假设现在需要设计医生，教师，公务员三个类，需要定义很多重复的内容而且相互没有关联，调用也没有规律。如果这还算好，那一个游戏有几千件物品，调用时也要写几千个函数。这太要命了。于是继承能力就应运而生了。</li></ol><p><strong>代码演示：</strong></p><ol><li>C++继承原理：C++的继承可以理解为在创建子类成员变量之前先创建父类的成员变量，实际上，C语言就是这么模仿出继承功能的。</li></ol><p><strong>用excel表格演示一下：</strong></p><ol><li>C++继承的注意事项。<ol><li>C++子类对象的构造过程。先调用父类的构造函数，再调用子类的构造函数，也就是说先初始化父类的成员，再初始化子类的成员。</li><li>若父类没有默认的构造函数，子类的构造函数又未调用父类的构造函数，则无法编译。</li><li>C++子类对象的析构过程。先调用父类的析构函数，再调用子类的析构函数。</li></ol></li></ol><p><strong>演示一下：</strong></p><p>总结：面向对象三大特性的继承就这么简单，很多人觉得类继承很复杂，其实完全不是这样的，只要明白子类在内存上其实就相当于把父类的成员变量放在子类的成员变量前面罢了。构造和析构过程也是为了这个机制而设计的。</p><h4 id="（-）虚函数及其实现原理，override关键字"><a href="#（-）虚函数及其实现原理，override关键字" class="headerlink" title="（**）虚函数及其实现原理，override关键字"></a>（**）虚函数及其实现原理，override关键字</h4><ol><li>虚函数介绍：<ol><li>虚函数就是面向对象的第三大特点：多态。多态非常的重要，它完美解决了上一课设计游戏装备类的问题，我们可以只设计一个函数，函数参数是基类指针，就可以调用子类的功能。比如射击游戏，所有的枪都继承自一个枪的基类，人类只要有一个开枪的函数就可以实现所有枪打出不同的子弹。</li><li>父类指针可以指向子类对象，这个是自然而然的，因为子类对象的内存前面就是父类成员，类型完全匹配。（<strong>不要死记硬背，尽量理解原理</strong>）</li><li>当父类指针指向子类对象，且子类重写父类某一函数时。父类指针调用该函数，就会产生以下的可能<ol><li><strong>该函数为虚函数：父类指针调用的是子类的成员函数。</strong></li><li><strong>该函数不是虚函数：父类指针调用的是父类的成员函数。</strong></li></ol></li></ol></li></ol><p><strong>代码演示</strong>：</p><ol><li>虚函数的注意事项：<ol><li>子父类的虚函数必须完全相同，为了防止开发人员一不小心将函数写错，于是C++11添加了override关键字。</li></ol></li></ol><p><strong>代码演示：</strong></p><ul><li><ol><li><strong>(*) 父类的析构函数必须为虚函数：这一点很重要，当父类对象指向子类对象时，容易使独属于子类的内存泄露。会造成内存泄露的严重问题。</strong></li></ol></li></ul><p><strong>代码演示</strong></p><ol><li>overide关键字的作用：前面已经说过了，为了防止开发人员将函数名写错了，加入了override关键字。</li><li><strong>虚函数实现多态的原理介绍</strong><ol><li>动态绑定和静态绑定：<ol><li>静态绑定：程序在编译时就已经确定了函数的地址，比如非虚函数就是静态绑定。</li><li>动态绑定：程序在编译时确定的是程序寻找函数地址的方法，只有在程序运行时才可以真正确定程序的地址，比如虚函数就是动态绑定。</li></ol></li><li>虚函数是如何实现动态绑定的呢？<ol><li>每个有虚函数的类都会有一个虚函数表，对象其实就是指向虚函数表的指针，编译时编译器只告诉了程序会在运行时查找虚函数表的对应函数。每个类都会有自己的虚函数表，所以当父类指针引用的是子类虚函数表时，自然调用的就是子类的函数。</li></ol></li></ol></li></ol><p><strong>代码演示：</strong></p><ol><li>总结：虚函数是C++类的重要特性之一，很简单，但使用频率非常高，至于如何实现的也要掌握。</li></ol><h4 id="静态成员变量与静态函数"><a href="#静态成员变量与静态函数" class="headerlink" title="静态成员变量与静态函数"></a>静态成员变量与静态函数</h4><ol><li>静态成员变量：<ol><li>Part2的第六节课就讲过C语言的静态成员变量，在编译期就已经在静态变量区明确了地址，所以生命周期为程序从开始运行到结束，作用范围为与普通的成员变量相同。这些对于类的静态成员变量同样适用。</li></ol></li></ol><p><strong>代码演示：</strong></p><ul><li><ol><li>类的静态成员变量因为创建在静态变量区，所以直接属于类，也就是我们可以直接通过类名来调用，当然通过对象调用也可以。</li></ol></li></ul><p><strong>代码演示：</strong></p><ol><li>静态成员变量的注意项：<ol><li>静态成员变量必须在类外进行初始化，否则会报未定义的错误，不能用构造函数进行初始化。因为静态成员变量在静态变量区，只有一份，而且静态成员变量在编译期就要被创建，成员函数那都是运行期的事情了</li></ol></li><li>静态成员函数的特点：静态成员函数就是为静态成员变量设计的，就是为了维持封装性。</li></ol><p><strong>代码演示：</strong></p><h4 id="（-）纯虚函数"><a href="#（-）纯虚函数" class="headerlink" title="（*）纯虚函数"></a>（*）纯虚函数</h4><ol><li>纯虚函数介绍：<ol><li>还是那个枪械射击的例子，基础的枪类有对应的对象吗？没有。它唯一的作用就是被子类继承。</li><li>基类的openfire函数实现过程有意义吗？没有。它就是用来被重写的。</li><li>所以纯虚函数的语法诞生了，只要将一个虚函数写为纯虚函数，那么该类将被认为无实际意义的类，无法产生对象。纯虚函数也不用去写实际部分。写了编译期也会自动忽略。</li></ol></li></ol><p><strong>代码演示：</strong></p><ol><li>纯虚函数的注意事项：<ol><li>没什么注意事项，这个语法非常简单。</li></ol></li><li>总结：纯虚函数的特点就是语法简单，却经常使用，必会。</li></ol><h4 id="RTTI："><a href="#RTTI：" class="headerlink" title="RTTI："></a>RTTI：</h4><p><strong>RTTI使用频率不是很高，但仍然有一定的意义，应当掌握。</strong></p><ol><li>RTTI介绍：<ol><li>RTTI（Run Time Type Identification）即通过运行时类型识别，程序能够通过基类的指针或引用来检查这些指针或引用所指向的对象的实际派生类。</li><li>C++为了支持多态，C++的指针或引用的类型可能与它实际指向对象的类型不相同，这时就需要rtti去判断类的实际类型了，<strong>rtti是C++判断指针或引用实际类型的唯一方式。</strong></li></ol></li><li>RTTI的使用场景：<strong>可能有很多人会疑惑RTTI的作用，所以单独拿出来说一下。</strong><ol><li>异常处理：这是RTTI最主要的使用场景，具体作用在异常处理章节会详细讲解。</li><li>IO操作：具体作用等到IO章节会详细讲解。</li></ol></li><li>RTTI的使用方式：RTTI的使用过程就两个函数<ol><li>typeid函数：typeid函数返回的一个叫做type_info的结构体，该结构体包括了所指向对象的实际信息，其中name()函数就可以返回函数的真实名称。type_info结构体其他函数没什么用.</li></ol></li></ol><p>代码演示：</p><ul><li><ol><li>dynamic_cast函数：C++提供的将父类指针转化为子类指针的函数。</li></ol></li></ul><p>代码演示：</p><ol><li>RTTI的注意事项：<ol><li><strong>当使用typeid函数时，父类和子类必须有虚函数（父类有了虚函数，子类自然会有虚函数），否则类型判断会出错。</strong></li></ol></li><li>RTTI总结：就是C++在运行阶段判断对象实际类型的唯一方式。</li></ol><h4 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h4><p><strong>首先提一下：多继承了解一下就可以了。</strong></p><ol><li>多继承的概念<ol><li>就是一个类同时继承多个类，在内存上，该类对象前面依次为第一个继承的类，第二个继承的类，依次类推。</li></ol></li></ol><p><strong>代码演示：</strong></p><ol><li>多继承的注意点：<ol><li>多继承最需要注意的点就是重复继承的问题，这个问题下一个将会详细讲解。</li><li>多继承会使整个程序的设计更加复杂，平常不推荐使用。C++语言中用到多继承的地方主要就是借口模式。相较于C++，java直接取消了多继承的功能，添加了借口。</li></ol></li><li>多继承的总结：多<strong>继承这个语法虽然在某些情况下使代码写起来更加简洁，但会使程序更加复杂难懂，一般来说除了借口模式不推荐使用。</strong></li></ol><h4 id="虚继承及其实现原理"><a href="#虚继承及其实现原理" class="headerlink" title="虚继承及其实现原理"></a>虚继承及其实现原理</h4><ol><li>虚继承的概念：虚继承就是为了避免多重继承时产生的二义性问题。虚继承的问题用语言不好描述，但用代码非常简单，所以直接写代码了。</li></ol><p><strong>代码演示：</strong></p><ol><li>虚继承的实现原理介绍：<ol><li>使用了虚继承的类会有一个虚继承表，表中存放了父类所有成员变量相对于类的偏移地址。</li><li>按照刚才的代码，B1，B2类同时有一个虚继承表，当C类同时继承B1和B2类时，每继承一个就会用虚继承表进行比对，发现该变量在虚继承表中偏移地址相同，就只会继承一份。</li></ol></li><li>虚继承的注意点：没什么需要注意的，语法简单。</li><li>虚继承的总结：这个语法就是典型的语法简单，但在游戏开发领域经常使用的语法，其它领域使用频率会低很多。</li></ol><h4 id="（-）移动构造函数与移动赋值运算符"><a href="#（-）移动构造函数与移动赋值运算符" class="headerlink" title="（**）移动构造函数与移动赋值运算符"></a>（**）移动构造函数与移动赋值运算符</h4><ol><li>对象移动的概念：<ol><li>对一个体积比较大的类进行大量的拷贝操作是非常消耗性能的，因此C++11中加入了“对象移动”的操作</li><li>所谓的对象移动，其实就是把该对象占据的内存空间的访问权限转移给另一个对象。比如一块内存原本属于A，在进行“移动语义”后，这块内存就属于B了。</li></ol></li><li>移动语义为什么可以提高程序运行效率。因为我们的各种操作经常会进行大量的“复制构造”，“赋值运算”操作。这两个操作非常耗费时间。移动构造是直接转移权限，这是不是就快多了。</li></ol><p><strong>注意：在进行转移操作后，被转移的对象就不能继续使用了，所以对象移动一般都是对临时对象进行操作（因为临时对象很快就要销毁了）。</strong></p><p><strong>代码演示：</strong></p><p>注意这里的右值引用不能是const的，因为你用右值引用函数参数就算为了让其绑定到一个右值上去的！就是说这个右值引用是一定要变的，但是你一旦加了const就没法改变该右值引用了。</p><ol><li><strong>默认移动构造函数和默认移动赋值运算符</strong></li></ol><p>会默认生成移动构造函数和移动赋值运算符的条件：</p><p><strong>只有一个类没有定义任何自己版本的拷贝操作（拷贝构造，拷贝赋值运算符），且类的每个非静态成员都可以移动，系统才能为我们合成。</strong></p><p><strong>可以移动的意思就是可以就行移动构造，移动赋值。所有的基础类型都是可以移动的，有移动语义的类也是可以移动的。</strong></p><h2 id="Part4：智能指针"><a href="#Part4：智能指针" class="headerlink" title="Part4：智能指针"></a>Part4：智能指针</h2><h4 id="（-）智能指针概述"><a href="#（-）智能指针概述" class="headerlink" title="（*）智能指针概述"></a>（*）智能指针概述</h4><ol><li>为什么要有智能指针：在Part2的第二节课已经讲过，直接使用new和delete运算符极其容易导致内存泄露，而且非常难以避免。于是人们发明了智能指针这种可以自动回收内存的工具。</li><li>智能指针一共就三种：普通的指针可以单独一个指针占用一块内存，也可以多个指针共享一块内存。<ol><li>共享型智能指针：shared_ptr，同一块堆内存可以被多个shared_ptr共享。</li><li>独享型智能指针：unique_ptr，同一块堆内存只能被一个unique_ptr拥有。</li><li>弱引用智能指针：weak_ptr，也是一种共享型智能指针，可以视为对共享型智能指针的一种补充</li></ol></li><li><strong>（*）智能指针注意事项：</strong></li></ol><p><strong>智能指针和裸指针不要混用，接下来的几节课会反复强调这一点。（这一点太重要了，所以上来就提了）</strong></p><h4 id="（-）shared-ptr"><a href="#（-）shared-ptr" class="headerlink" title="（*）shared_ptr"></a>（*）shared_ptr</h4><ol><li><strong>shared_ptr的工作原理</strong><ol><li>我们在动态分配内存时，堆上的内存必须通过栈上的内存来寻址。也就是说栈上的指针（堆上的指针也可以指向堆内存，但终究是要通过栈来寻址的）是寻找堆内存的唯一方式。</li><li>所以我们可以给堆内存添加一个引用计数，有几个指针指向它，它的引用计数就是几，当引用计数为0是，操作系统会自动释放这块堆内存。</li></ol></li><li><strong>Shared_ptr的常用操作</strong><ol><li><strong>shared_ptr的初始化</strong><ol><li><strong>使用new运算符初始化</strong></li></ol></li></ol></li></ol><p><strong>代码演示：</strong></p><p>一般来说不推荐使用new进行初始化，因为C++标准提供了专门创建shared_ptr的函数“make_shared”，该函数是经过优化的，效率更高。</p><ul><li><ul><li><ol><li><strong>使用make_shared函数进行初始化：</strong></li></ol></li></ul></li></ul><p><strong>代码演示：</strong></p><p><strong>注意：千万不要用裸指针初始化shared_ptr，容易出现内存泄露的问题。</strong></p><ul><li><ul><li><ol><li><strong>当然使用复制构造函数初始化也是没有问题的。</strong></li></ol></li></ul></li></ul><p>代码演示:</p><ul><li><ol><li><strong>shared_ptr的引用计数：</strong></li></ol></li></ul><p>智能指针就是通过引用计数来判断释放堆内存时机的。</p><p>use_count()函数可以得到shared_ptr对象的引用计数。</p><p><strong>代码演示：</strong></p><ol><li><strong>智能指针可以像普通指针那样使用，”share_ptr”早已对各种操作进行了重载，就当它是普通指针就可以了。</strong></li></ol><p><strong>代码演示：</strong></p><ol><li><strong>Shared_ptr的常用函数</strong><ol><li>unique函数：判断该shared_ptr对象是否独占若独占，返回true。否则返回false。</li></ol></li></ol><p>代码演示：</p><ul><li><ol><li>reset函数：<ol><li>当reset函数有参数时，改变此shared_ptr对象指向的内存。</li><li>当reset函数无参数时，将此shared_ptr对象置空，也就是将对象内存的指针设置为nullptr。</li></ol></li></ol></li></ul><p>代码演示：</p><ul><li><ol><li><strong>get函数，强烈不推荐使用：</strong></li></ol></li></ul><p>代码演示：</p><p><strong>如果一定要使用，那么一定不能delete返回的指针。</strong></p><ul><li><ol><li>swap函数：交换两个智能指针所指向的内存<ol><li>std命名空间中全局的swap函数</li><li>shared_ptr类提供的swap函数</li></ol></li></ol></li></ul><ol><li><strong>关于智能指针创建数组的问题。</strong></li></ol><p><strong>代码演示：</strong></p><ol><li><strong>用智能指针作为参数传递时直接值传递就可以了。</strong>shared_ptr的大小为固定的8或16字节（也就是两倍指针的的大小，32位系统指针为4个字节，64位系统指针为8个字节，shared_ptr中就两个指针），所以直接值传递就可以了。</li></ol><p>代码演示：</p><ol><li><strong>shared_ptr总结：</strong>在现代程序中，当想要共享一块堆内存时，优先使用shared_ptr，可以极大的减少内存泄露的问题。</li></ol><h4 id="（-）weak-ptr"><a href="#（-）weak-ptr" class="headerlink" title="（*）weak_ptr"></a>（*）weak_ptr</h4><ol><li><strong>weak_ptr介绍：</strong><ol><li>这个智能指针是在C++11的时候引入的标准库，它的出现完全是为了弥补shared_ptr天生有缺陷的问题，其实shared_ptr可以说近乎完美。</li><li>只是通过引用计数实现的方式也引来了引用成环的问题，这种问题靠它自己是没办法解决的，所以在C++11的时候将shared_ptr和weak_ptr一起引入了标准库，用来解决循环引用的问题。</li></ol></li><li><strong>shared_ptr的循环引用问题：</strong></li></ol><ol><li><strong>weak_ptr的作用原理：</strong>weak_ptr的对象需要绑定到shared_ptr对象上，作用原理是weak_ptr不会改变shared_ptr对象的引用计数。只要shared_ptr对象的引用计数为0，就会释放内存，weak_ptr的对象不会影响释放内存的过程。</li></ol><p>重新回到刚才的代码：</p><ol><li>weak_ptr的总结：<strong>weak_ptr使用较少，就是为了处理shared_ptr循环引用问题而设计的。</strong></li></ol><h4 id="（-）unique-ptr"><a href="#（-）unique-ptr" class="headerlink" title="（*）unique_ptr"></a>（*）unique_ptr</h4><ol><li><strong>uniqe_ptr介绍：</strong>独占式智能指针，在使用智能指针时，我们一般优先考虑独占式智能指针，因为消耗更小。如果发现内存需要共享，那么再去使用“shared_ptr”。</li><li><strong>unique_ptr的初始化</strong>：和shared_ptr完全类似<ol><li>使用new运算符进行初始化</li></ol></li></ol><p>代码演示：</p><ul><li><ol><li>使用make_unique函数进行初始化</li></ol></li></ul><p>代码演示：</p><ol><li><strong>unique_ptr的常用操作</strong><ol><li>unque_ptr禁止复制构造函数，也禁止赋值运算符的重载。否则独占便毫无意义。、</li></ol></li></ol><p><strong>代码演示：</strong></p><ul><li><ol><li>unqiue_ptr允许移动构造，移动赋值。移动语义代表之前的对象已经失去了意义，移动操作自然不影响独占的特性。</li></ol></li></ul><p><strong>代码演示：</strong></p><ul><li><ol><li>reset函数：<ol><li>不带参数的情况下：释放智能指针的对象，并将智能指针置空。</li><li>带参数的情况下：释放智能指针的对象，并将智能指针指向新的对象。</li></ol></li></ol></li></ul><p><strong>代码演示：</strong></p><ol><li><strong>将unque_ptr的对象转化为shared_ptr对象，</strong>当unique_ptr的对象为一个右值时，就可以将该对象转化为shared_ptr的对象。</li></ol><p><strong>这个使用的并不多，需要将独占式指针转化为共享式指针常常是因为先前设计失误。</strong></p><p><strong>注意：shared_ptr对象无法转化为unique_ptr对象。</strong></p><p><strong>代码演示：</strong></p><h4 id="（-）智能指针的使用范围"><a href="#（-）智能指针的使用范围" class="headerlink" title="（**）智能指针的使用范围"></a>（**）智能指针的使用范围</h4><p>这节课一共就几句话，但仍然是两个（*），足以说明如何使用智能指针的重要性。</p><ol><li><strong>能使用智能指针就尽量使用智能指针，那么哪些情况属于不能使用智能指针的情况 呢？</strong></li></ol><p>有些函数必须使用C语言的指针，这些函数又没有替代，这种情况下，才使用普通的指针，其它情况一律使用智能指针。</p><p>必须使用C语言指针的情况包括：</p><ol><li><strong>网络传输函数</strong>，比如windows下的send，recv函数，只能使用c语言指针，无法替代.</li><li><strong>c语言的文件操作部分</strong>。这方面C++已经有了替代品，C++的文件操作完全支持智能指针，<strong>所以在做大型项目时，推荐使用C++的文件操作功能（Part7会详细讲解）。</strong></li></ol><p><strong>除了以上两种情况，剩下的均推荐使用智能指针。</strong></p><ol><li><strong>我们应该使用哪个智能指针呢？</strong></li><li><strong>优先使用unique_ptr，内存需要共享时再使用shared_ptr。</strong></li><li><strong>当使用shared_ptr时，如果出现了循环引用的情况，再去考虑使用weak_ptr。</strong></li><li><strong>总结：智能指针部分就这样了，东西真的不多，但都非常重要，很常用的。</strong></li></ol><h2 id="Part5：模板与泛型编程"><a href="#Part5：模板与泛型编程" class="headerlink" title="Part5：模板与泛型编程"></a>Part5：模板与泛型编程</h2><h4 id="（-）模板介绍，类模板与模板实现原理"><a href="#（-）模板介绍，类模板与模板实现原理" class="headerlink" title="（*）模板介绍，类模板与模板实现原理"></a>（*）模板介绍，类模板与模板实现原理</h4><ol><li><strong>模板的重要性</strong>：<strong>模板是C++最重要的模块之一，很多人对模板的重视不够，这一章一定要好好学，所有课时都是重点。</strong></li></ol><p><strong>C++的三大模块，面向过程，面向对象，模板与泛型。面向过程就是C语言，面向对象就是类，现在轮到模板与泛型了。</strong></p><ol><li><strong>模板的介绍：</strong><ol><li>模板能够实现一些其他语法难以实现的功能，但是理解起来会更加困难，容易导致新手摸不着头脑。</li><li>模板分为类模板和函数模板，函数模板又分为普通函数模板和成员函数模板。</li></ol></li><li><strong>类模板基础：</strong></li></ol><p>这节课讲一下类模板，函数模板下一课再讲</p><ul><li><ol><li>类模板的写法与使用十分固定</li></ol></li></ul><p><strong>代码演示：注意，这段代码非常有代表性，在下一课补完后，一定要掌握，多看几遍。</strong></p><ol><li><strong>模板的实现原理：</strong></li></ol><p>模板需要编译两次，在第一次编译时仅仅检查最基本的语法，比如括号是否匹配。等函数真正被调用时，才会真正生成需要的类或函数。</p><p>所以这直接导致了一个结果，就是不论是模板类还是模板函数，声明与实现都必须放在同一个文件中。因为在程序在编译期就必须知道函数的具体实现过程。如果实现和声明分文件编写，需要在链接时才可以看到函数的具体实现过程，这当然会报错。</p><p>于是人们发明了.hpp文件来存放模板这种声明与实现在同一文件的情况。</p><h4 id="（-）initializer-list与typename"><a href="#（-）initializer-list与typename" class="headerlink" title="（*）initializer_list与typename"></a>（*）initializer_list与typename</h4><ol><li>initializer_list的用法<ol><li>initializer_list介绍：initializer_list其实就是初始化列表，我们可以用初始化列表初始化各种容器，比如“vector”，“数组”。</li></ol></li></ol><p>代码演示：</p><ul><li><ol><li>这节课的主要任务是在上一课的代码中加入initializer_list。</li></ol></li></ul><p><strong>代码演示：</strong></p><ol><li>typename的用法<ol><li>在定义模板时表示这个一个待定的类型</li></ol></li></ol><p><strong>代码演示：</strong></p><ul><li><ol><li>在类外表明自定义类型时使用</li></ol></li></ul><p><strong>代码演示：</strong></p><p><strong>在C++的早期版本，为了减少关键字数量，用class来表示模板的参数，但是后来因为第二个原因，不得不引入typename关键字。</strong></p><h4 id="（-）函数模板，成员函数模板"><a href="#（-）函数模板，成员函数模板" class="headerlink" title="（*）函数模板，成员函数模板"></a>（*）函数模板，成员函数模板</h4><ol><li>普通函数模板的写法与类模板类似</li></ol><p><strong>代码演示：</strong></p><p><strong>在现代C++中，函数模板一直普遍使用，一定要掌握。</strong></p><ol><li>成员函数模板</li></ol><p><strong>代码演示：</strong></p><p>成员函数模板使用情况也不少，需要掌握的</p><h4 id="（-）默认模板参数"><a href="#（-）默认模板参数" class="headerlink" title="（*）默认模板参数"></a>（*）默认模板参数</h4><p>默认模板参数：</p><ol><li>默认模板参数是一个经常使用的特性，比如在定义vector对象时，我们就可以使用 默认分配器。</li><li>模板参数就和普通函数的默认参数一样，一旦一个参数有了默认参数，它之后的参 数都必须有默认参数<ol><li>函数模板使用默认模板参数</li></ol></li></ol><p><strong>代码演示：</strong></p><ul><li><ol><li>类模板使用模板参数</li></ol></li></ul><p><strong>代码演示：</strong></p><p>类模板使用模板参数的注意点：</p><h4 id="（-）模板的重载，全特化和偏特化"><a href="#（-）模板的重载，全特化和偏特化" class="headerlink" title="（*）模板的重载，全特化和偏特化"></a>（*）模板的重载，全特化和偏特化</h4><ol><li>模板的重载<ol><li>函数模板是可以重载的（类模板不能被重载），通过重载可以应对更加复杂的情况。比如在处理char*和string对象时，虽然都可以代表字符串，但char*在复制时直接拷贝内存效率明显更高，string就不得不依次调用构造函数了。所以在一些比较最求效率的程序中对不同的类型进行不同的处理还是非常有意义的。</li></ol></li></ol><p><strong>代码演示：</strong></p><p>其实函数模板的重载和普通函数的重载没有什么区别。</p><p>在讲完类模板的特化后就能知道重载和特化的区别了，这一点暂时不用在意。</p><ol><li>模板的特化<ol><li>模板特化的意义：函数模板可以重载以应对更加精细的情况。类模板不能重载，但可以特化来实现类似的功能。</li><li>模板的特化也分为两种，全特化和偏特化。模板的全特化：就是指模板的实参列表与与相应的模板参数列表一一对应。</li></ol></li></ol><p>这么说可能有些繁琐，直接看代码其实并不复杂，</p><p><strong>代码演示：</strong></p><ul><li><ol><li>模板的偏特化：偏特化就是介于普通模板和全特化之间，只存在部分类型明确化，而非将模板唯一化。</li></ol></li></ul><p><strong>代码演示：</strong></p><ul><li><ol><li><strong>其实对于函数模板来说，特化与重载可以理解为一个东西。</strong></li></ol></li></ul><p><strong>总结：函数模板的重载，类模板的特化。还是比较重要的知识点，应当掌握，在一些比较复杂的程序中，模板重载与特化是经常使用的。</strong></p><h2 id="Part6：stl标准库"><a href="#Part6：stl标准库" class="headerlink" title="Part6：stl标准库"></a>Part6：stl标准库</h2><h4 id="（-）stl介绍与6大模块介绍"><a href="#（-）stl介绍与6大模块介绍" class="headerlink" title="（*）stl介绍与6大模块介绍"></a>（*）stl介绍与6大模块介绍</h4><ol><li>stl的介绍：<ol><li>stl就是（standard template library）的简称，定义在std命名空间中，定义了C++常用的容器与算法等。</li></ol></li></ol><p>可以说stl极大的提高了我们的程序开发效率。</p><p><strong>在C++开发中，可以说：不会用stl的人，会用stl但不懂stl实现原理的人，既会使用stl，又懂得stl实现原理的人是完完全全的三个档次。</strong></p><ul><li><ol><li>泛型编程的概念：用模板进行编程，可以实现一些其它方式难以实现的功能，但对于新手来说，泛型编程可能会难以理解，摸不着头脑。</li></ol></li></ul><p>也就是说，模板是学习泛型编程的基础。</p><p><strong>注意：泛型编程不属于面向对象编程的范畴，泛型编程和面向对象编程是并列的。</strong></p><ul><li><ol><li>stl作为泛型编程的最典型代表，它实现了其它编程方式难以实现的效果，比如将整个模板库分为六个部分，每个部分可以单独设计。举个最简单的例子，vector和map在数据结构方面完全不一样，但stl可以设计出“迭代器”这个模块，让该模块可以在不同的数据结构中按照同样的方式运行。这种技术没有泛型编程是难以实现的。</li></ol></li></ul><ol><li>学习stl的注意事项<ol><li><strong>学习stl一定要有全局观念，不要局限于单个容器，重点在于明白六大组件之间的联系。</strong></li><li><strong>当然，如果只是单纯为了应付当前的业务，单独学一下某个容器的用法也没有问题。</strong></li></ol></li><li>SLT的六大容器介绍：<ol><li>容器（container）：是一种数据结构，也就是真正用来存储数据的地方。分为三类<ol><li>顺序式容器：</li><li>关联式容器：</li><li>无序式容器：其实无序式容器也是一种关联式容器，但是既然C++标准委员会将无序容器与关联式容器平行的列了出来，那么我们这里也就让无序式容器和关联式容器平行吧。</li></ol></li><li>迭代器（iterator）：提供了可以访问任何容器的方法。</li><li>算法（alogorithm）：用来操作容器中的数据的模板函数。</li><li>仿函数（functor）</li><li>适配器（adaptor）</li><li>分配器（allocator）</li></ol></li></ol><p>这一课只要知道有这六大模块就可以了。至于这六大模块是干什么的，后面慢慢介绍。</p><h4 id="（-）容器"><a href="#（-）容器" class="headerlink" title="（*）容器"></a>（*）容器</h4><p><strong>容器的各项操作我已经单独列出来的了，就在附页3。这里只介绍最核心的操作。</strong></p><p><strong>这门课就不讲基础的数据结构了，这些东西建议熟练之后用来提升自己。数组，链表，树，哈希表如果不明白，可以去百度一下，新手了解概念就可以了。</strong></p><ol><li>顺序容器（sequence container）：每个元素都有固定的位置，<strong>位置取决于插入时间和地点，与元素的值无关</strong><ol><li>vector：<strong>将元素置于一个动态数组中，可以随机存储元素（也就是用索引直接存取）。</strong></li></ol></li></ol><p>数组尾部添加或删除元素非常迅速。但在中部或头部就比较费时。</p><p><strong>代码演示：</strong></p><ul><li><ol><li>deque：“double end queue”的缩写，也就是双端队列。<strong>deque的实现相比于vector有些复杂，但本质仍然是优化过的动态数组，只不过相比于单纯的动态数组，在前面添加或删除元素非常快了。</strong></li></ol></li></ul><p><strong>可以随机存储元素。</strong>头部和尾部添加或删除元素都非常快（略慢与vector）。但在 中间插入元素比较费时（和vector差不多）。</p><p><strong>代码演示：</strong></p><ul><li><ol><li>list：本质就是链表，所以自然具有了链表的属性。</li></ol></li></ul><p><strong>不能随机存取元素（也就是list无法用索引存取元素）</strong>。在任何位置插入和删除元 素都比较迅速。（在任何位置插入删除元素的时间相同，在元素头部操作慢于deque，在元素尾部操作慢于deque和vector）</p><p><strong>代码演示：</strong></p><ul><li><ol><li>string：没什么好说的，就是把普通字符串封装了一下</li></ol></li></ul><p>代码演示：</p><ul><li><ol><li>forward_list：单项链表，简单来说就是受限的list，凡是list不支持的功能，它都不支持。做各种支持的操作效率都会高于list，最典型的就排序算法了，forword_list要优于list。<ol><li>ForwordList 只提供前向迭代器，而不是双向迭代器。因此它也不支持反向迭代器。</li><li>ForwordList不提供成员函数 size()。</li><li>ForwordList 没有指向最末元素的锚点。基于这个原因，不提供用以处理最末元素的成员 back(),push_back(),pop_back()。</li></ol></li></ol></li></ul><ol><li>关联容器（associated container）：<strong>元素位置取决于元素的值，和插入顺序无关。</strong><ol><li>set/multiset：使用“红黑树”实现，是一种高度平衡的二叉树，如果大家不了解红黑树，可以去百度一下。了解个大概就可以了。<strong>二叉树的本质决定了set/multiset的元素存取值取决于元素本身的值，和插入顺序无关。</strong></li></ol></li></ol><p>内部元素的值依据元素的值自动排列，与插入顺序无关。set内部相同数值的元素只能出现一次，multiset内部相同数值的元素可出现多次。容器用二叉树实现，便于查找。</p><p><strong>代码演示：</strong></p><ul><li><ol><li>map/multimap：使用“红黑树”实现，是一种高度平衡的二叉树。</li></ol></li></ul><p>内部元素是成对的“key/value”，也就是“键值/实值”，内部元素依据其键值自动排序，map内部相同的键值只能出现一次，multimap则可以出现多次。</p><p><strong>代码演示：</strong></p><ol><li>无序式容器（unordered container）：<ol><li>unordered_map/unordered_multimap：使用“哈希表”实现的，由于哈希表的特性，实现了真正的无序。如果不理解为什么使用“哈希表”就是真正无序的，可以去百度一下“哈希表”，或者干脆直接记住就可以了。</li></ol></li></ol><p>使用方法也是“key/value”，和map/multimap类似。</p><ul><li><ol><li>unordered_set/unorder_multiset：同样使用“哈希表”实现的。自然具有了哈希表实现的容器的特点。</li></ol></li></ul><p>使用方法和setl/multiset类似。</p><ol><li>关联式容器和无序式容器的对比：<ol><li><strong>关联式容器都是有序的，对于那些对顺序有要求的操作，关联式容器效率会高很多。（比如增加元素，删除元素）</strong></li><li><strong>无序容器都是真正的无序，在查找数据方面有着优势。（比如修改特定元素，查找元素）</strong></li><li><strong>从内存消耗的角度讲，无序容器要高于关联容器不过这并不重要。</strong></li></ol></li></ol><p><strong>一句话来说，如果从这两类容器中选一个使用的话。如果是增加，删除元素比较频繁，就使用关联式容器。如果修改元素，查找元素比较平凡，就使用无序容器。</strong></p><ol><li><strong>我们在处理数据时应该选择什么容器呢？</strong><ol><li><strong>在我们需要使用存储“key/value”的容器时，只能使用map/multimap/unoredered_map/unordered_multimap。如果增加删除频繁，就使用map/multimap，修改，查找频繁，就使用unordered_map/unoredered_multimap。</strong></li></ol></li></ol><p><strong>在真正的大型项目中，常常会对这两种容器进行测试，普通练习靠感觉就可以了</strong></p><ul><li><ol><li><strong>在处理普通元素：</strong><ol><li><strong>当元素需要频繁插入删除时，选择顺序容器。</strong><ol><li><strong>如果在尾部插入删除，选择vector</strong></li><li><strong>在头部，尾部插入删除，选择deque</strong></li><li><strong>在中间插入，删除，选择list</strong></li></ol></li><li><strong>当元素需要频繁查找时，选择.set/multiset/unorder_set/unorder_multiset。</strong><ol><li><strong>频繁增加，删除时，选set，</strong></li><li><strong>频繁查找，修改时，选ordered_set</strong></li></ol></li></ol></li></ol></li></ul><p><strong>我们发现，对于普通元素，容器的选择不怎么容易判断。</strong></p><p><strong>其实在真正的大型项目中，要对各种容器进行测试的，普通练习一般选择vector或set就可以了。这两个使用是比较频繁的，</strong></p><h4 id="（-）迭代器"><a href="#（-）迭代器" class="headerlink" title="（*）迭代器"></a>（*）迭代器</h4><ol><li>迭代器介绍：<strong>迭代器提供了一种可以顺序访问容器各个元素的方法，可以让我们无视不同容器存储方式的不同，用同一的方式访问数据。经过前面对容器的学习，相信大家已经体会到这一点了。</strong></li><li>迭代器的作用：能够让迭代器与容器，算法在设计，使用时互不干扰，又能无缝耦合起来。使用迭代器可以灵活操作各种容器算法，而不需要考虑不同容器间的差异。</li></ol><h4 id="（-）算法"><a href="#（-）算法" class="headerlink" title="（*）算法"></a>（*）算法</h4><ol><li>stl的算法可以分为九个种类，具体有什么已经在“<strong>附录一</strong>”中完全列举了。<ol><li>查找算法：</li><li>排序算法：</li><li>删除和替换算法：</li><li>排列组合算法：</li><li>算数算法：</li><li>生成和异变算法：</li><li>关系算法：</li><li>集合算法：</li><li>堆算法：</li></ol></li></ol><p><strong>在这里只列举一些比较常用的，剩下的那些大家如果使用可以在“附录一”中查找。</strong></p><p><strong>代码演示：</strong></p><h4 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h4><ol><li>仿函数定义：就是一个可以调用“()”运算符的类对象，在Part2的第10节，Part3的第五节就已经详细介绍过仿函数了。将operator()重载的类的对象就是仿函数。</li></ol><p>简单来说，就是我们在用算法时最后一个参数需要一个可调用对象，stl本身已经帮我们定义了很多可调用对象，不用我们自己再去定义了。</p><h4 id="适配器与分配器"><a href="#适配器与分配器" class="headerlink" title="适配器与分配器"></a>适配器与分配器</h4><ol><li>什么是容器适配器：“适配器是使一种事物的行为类似于另外一种事物行为的一种机制”。适配器对容器进行包装，使其表现出另外一种行为。例如：stack<int>实现了栈的功能，内部默认使用deque<int>容器来存储数据。</int></int></li><li>STL的适配器有哪些：标准库提供了三种顺序容器适配器，没有关联型容器的适配器。分别是queue（队列），priority_queue（优先级队列），stack（栈）。</li><li>适配器的使用：<ol><li>要使用适配器，首先需要引入对应的头文件<ol><li>要使用stack， 需要#include<stack></stack></li><li>要使用queue或priority_queue， 需要#include<queue></queue></li></ol></li></ol></li></ol><p>代码演示：</p><ul><li><ol><li>容器适配器必须有匹配的容器：如图所示</li></ol></li></ul><div class="table-container"><table><thead><tr><th>种类</th><th>默认顺序容器</th><th>可用顺序容器</th><th>说明</th></tr></thead><tbody><tr><td>stack</td><td>deque</td><td>vector, deque,list</td><td></td></tr><tr><td>queue</td><td>deque</td><td>list,deque</td><td>基础容器必须提供push_front()y运算</td></tr><tr><td>priority_queue</td><td>vector</td><td>vector, deque</td><td>基础容器必须提供随机访问的功能</td></tr></tbody></table></div><p>代码演示：</p><ul><li><ol><li>适配器的初始化：<ol><li>普通的初始化方式： stack<int>stk。</int></li><li>覆盖默认容器类型的初始化方式： stack<int, vector<int>&gt; stk</int></li></ol></li></ol></li></ul><ol><li>分配器提一下就可以了。在分配动态内存时，直接使用new，delete容易产生内存碎片化的问题，不同的分配器有不同的分配内存的方法，可以大幅提高程序对堆内存的使用效率，我们直接使用默认的分配器就可以了</li></ol><h2 id="Part7：io库"><a href="#Part7：io库" class="headerlink" title="Part7：io库"></a>Part7：io库</h2><h4 id="io库介绍"><a href="#io库介绍" class="headerlink" title="io库介绍"></a>io库介绍</h4><ol><li>io就是input，output的简写，也就是输入输出功能。在Part2的第4节课，就已经介绍过io功能的本质，数据在内存，磁盘，输入输出设备之间移动就是io功能。</li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66ba0139d9c307b7e92e27fc.jpg" alt="code"></p><ol><li>io库组成部分：<ol><li>C++定义了ios这个基类来定义输入输出的最基本操作，这个类的具体功能我们无需了解，只需了解C++io库所有的类都继承自这个类即可。</li><li>istream，ostream这两个类直接继承自ios类。<ol><li>ostream类定义了从内存到输出设备（比如显示器）的功能，我们最常使用的cout就是ostream类的对象。</li><li>istream类定义了从输入设备比如键盘）到内存的功能，我们最常用的cin就是istream类的对象。</li><li><strong>iostream文件定义了ostream和istream类的对象，就是cout和cin。所以我们只要简单的引入iostream这个头文件，就可以方便的使用这两个对象</strong></li></ol></li></ol></li></ol><p><strong>注意：这个输入，输入时相对于内存来说的，输入到内存，是istream。</strong></p><ul><li><ol><li>ifstream，ofstream类分别继承自istream类和ostream类。<ol><li>ifstream定义了从磁盘到内存的功能。因为istream重载了“&lt;&lt;”运算符，所以ifstream对象也可以用“&lt;&lt;”运算符来将文件数据写入内存。除了“=”的所有重载运算符都是可以被继承的。</li><li>ofstream定义了从内存到磁盘的功能。与ifstream同理，也可以用“&gt;&gt;”操作数据流。</li><li><strong>fstream文件引入了ifstream和ofstream，所以我们只要引入ftream这个头文件，就可以使用文件流功能了。</strong></li></ol></li></ol></li></ul><p>注意：这个输入输出同样是相对内存来说的。</p><p>内存与输入输出设备的数据流动，磁盘与内存的数据流动已经介绍完了。磁盘和输入输出设备直接无法直接交互，必须通过内存。</p><p>io库还为我们额外定义了字符串的输入输出类，因为对字符串的操作极为频繁，所以这个库还是很有意义的。</p><ul><li><ol><li>istringstream，ostringstream分别继承自istream类和ostream类<ol><li>istringstream定义了从指定字符串到特定内存的功能。与ifstream同理，也可以用“&lt;&lt;”运算符操作数据。</li><li>ostringstream定义了从特定内存到指定字符串的功能。可以用“&gt;&gt;”操作数据。</li><li><strong>sstream头文件就引入了istringstream和ostringstream，所以我们只要引入sstream这个头文集，就可以使用字符串与内存直接交互数据的功能。</strong></li></ol></li></ol></li></ul><p>所以我们使用io库主要就三个头文件，iostream，fstream，sstream。接下来三节课会对这三个文件的使用依次讲解。</p><h4 id="（-）io库的注意事项"><a href="#（-）io库的注意事项" class="headerlink" title="（*）io库的注意事项"></a>（*）io库的注意事项</h4><p><strong>提示：这节课的介绍，这节课都是一些理论性的东西，有疑惑很正常，可以带着疑惑去学下一节课，有了代码就好理解了。</strong></p><ol><li><strong>io对象无法使用拷贝构造函数和赋值运算符</strong></li></ol><p>代码演示：</p><p>所以我们使用流对象无法使用值传递，一般使用引用进行传递。</p><ol><li><strong>Io对象的状态</strong><ol><li><strong>io操作是非常容易出现错误的操作，一些错误是可以修复的，另一部分则发生在系统更深处，已经超出了应用程序可以修正的范围。</strong></li></ol></li></ol><p>比如我们使用cin向一个int类型的数中输入一个字符串，会使cin这个对象出现错误。</p><p><strong>代码演示：</strong></p><p><strong>所以我们在使用io对象时都应该判断io对象的状态。</strong></p><p><strong>比如：while(cin &gt;&gt; val) 或if(cin &gt;&gt; val)（不要只用这两个进行控制，最好搭配iostate来使用）</strong></p><p><strong>代码演示：</strong></p><ul><li><ol><li>我们需要知道流对象错误的原因，因为不同的错误需要不同的处理方法。</li></ol></li></ul><p>io库定义了iostate类型，可以完整的表示io对象当前的状态。在不同的平台中， iostate实现方法略有区别，在vs中直接用int来代表iostate类型，将不同的位置1 以表示不同的状态。可以与位操作符一起使用来一次检测或设置多个标志位。</p><p>可以用<strong>rdstat函数</strong>来获得io对象当前用iostat类型来表示的状态：</p><p><strong>代码演示：</strong></p><ul><li><ol><li>iostata类型有以下状态<ol><li>badbit状态，系统级错误，一旦表示badbit的位被置为1，流对象就再也无法使用了。</li><li>failbit状态，代表可恢复错误，比如想读取一个数字却读取了一个字符，这种错误就是可以恢复的。当badbit位被置1时，failbit位也会被置1。</li><li>eofbit状态，当到达文件结束位置时，eofbit和failbit位都会被置1。</li><li>goodbit状态，表示流对象没有任何错误。</li></ol></li></ol></li></ul><p>只要badbit，failbit，eofbit有一位被置为1，则检测流状态的条件就会失败。</p><ul><li><ol><li>标准库还定义了一组成员函数来查询这些标志位的状态<ol><li>good()函数在所有错误位均未置1的情况下返回true。</li><li>bad()，fail()，eof()函数在对应位被置1的情况下返回true。因为badbit位被置1或eofbit位被置1时，failbit位也会被置为1。所以用fail()函数可以准确判断出流对象是否出现错误。</li><li>实际上，我们将流对象当做条件使用的代码就等价于“!fail()”</li></ol></li><li>流对象的管理<ol><li>rdstate函数，返回一个iostate值，对应当前流状态</li><li>setstate(flag) 函数，将流对象设置为想要的状态</li><li>clear函数：是一个重载的函数。<ol><li>clear()，将所有位置0，也就是goodbit状态。</li><li>clear(flag)，将对应的条件状态标志位复位。</li></ol></li><li>ignore函数：</li></ol></li></ol></li></ul><p>作用：提取输入字符并丢弃他们。</p><p>函数原型：istream&amp; ignore (streamsize n = 1, int delim = EOF)</p><pre><code>             读取到前n个字符或在读这n个字符进程中遇到delim字符就停止，把读取的这些东西丢掉
</code></pre><p>代码演示：</p><h4 id="内存与输入输出设备的交互（iostream）"><a href="#内存与输入输出设备的交互（iostream）" class="headerlink" title="内存与输入输出设备的交互（iostream）"></a>内存与输入输出设备的交互（iostream）</h4><ol><li><strong>getline：</strong></li></ol><p>其实iostream已经没什么好讲的了，比较常用的就是这个getline了，getline其实并不复杂，不过是按行接收数据罢了，<strong>因为存储在string对象中，所以不容易出现格式错误，但仍然可能出现系统错误，所以在企业级程序中，还是应当对bad的情况进行处理。</strong></p><p>代码演示：</p><ol><li><strong>get:</strong></li></ol><p>还有个不怎么常用的get函数。get函数的用法和getline类似，只不过get是以字符的格式进行接收。<strong>在企业级代码中仍然需要对bad的情况进行处理。</strong></p><p><strong>剩下的也没什么了，iostream常见的用法在上一课已经讲过了，iostream就这些了。</strong></p><h4 id="（-）内存与磁盘的交互（fstream）"><a href="#（-）内存与磁盘的交互（fstream）" class="headerlink" title="（*）内存与磁盘的交互（fstream）"></a>（*）内存与磁盘的交互（fstream）</h4><ol><li>fstream相对于iostream。多了很多自己独有的操作<ol><li>i<strong>o库默认没有给ifstream和ofstream类提供对象，需要我们自己去定义。</strong></li><li>fstream对象创建方式有三种<ol><li>可以使用默认构造函数进行定义。例如： ifstream fstrm，</li></ol></li></ol></li></ol><p>代码演示：</p><ul><li><ul><li><ol><li>也可以在创建流对象时打开想要打开的文件。例如ifstream fstrm(s)。s可以是字符串，也可以是c风格的字符串指针。文件的mode依赖于流对象的类型。</li></ol></li></ul></li></ul><p>代码演示：</p><ul><li><ul><li><ol><li>也可以在打开文件时就指定文件的mode。例如ifstream fstrm(s, mode)</li></ol></li></ul></li></ul><p>代码演示：</p><ul><li><ol><li>fstrm.open(s)函数，打开名为s的文件，并将文件与fsrm绑定，s可以是一个string，也可以是一个c风格的字符串指针。</li></ol></li></ul><p>代码演示：</p><ul><li><ol><li>fstrm.close()函数，关闭文件。<strong>注意，一定不要忘了。</strong></li></ol></li></ul><p>代码演示：</p><ul><li><ol><li>fstrm.is_open()函数，返回一个bool值，指出与fstrm关联的文件是否成功打开且尚未关闭。</li></ol></li></ul><p>代码演示：</p><p><strong>如果新手只看这些描述，可能会很迷糊，所以我接下来要写一段代码，大家只要把这段代码记住，文件部分就没有问题了。</strong></p><p><strong>这段代码的目的是：让客户输入文件名称，如果文件不存在，就让客户重新输入文件名称，如果文件存在，就将文件全部内容输出。</strong></p><ol><li>文件模式：<ol><li>in以读的方式打开</li><li>out以写的方式打开</li><li>app在进行写操作时定位到文件末尾</li><li>ate打开文件后立即定位到文件末尾</li><li>trunc截断文件（也就是文件已有的全部删除，重新开始写）</li><li>binary以二进制方式打开文件</li></ol></li><li>文件模式需要强调以下几点<ol><li>与ifstream关联的文件默认in模式打开。</li><li>与ofstream关联的文件默认out模式打开</li><li>与fstream关联的文件默认in和out模式打开</li><li>默认情况下，即使我们没有指定trunc，以out模式打开的文件也会被截断。为了保持以out模式打开的文件的内容，我们必须同时指定app模式或in模式。</li><li>只可以对ifstream或fstream的对象设定in的模式</li><li>只可以对ofstream或fstream的对象设定out的模式</li><li>只有当out模式被设置时才可以设置trunc模式</li><li>ate和binary模式可以应用与任何类型的文件流对象，且可以与任何其它文件模式组合使用。</li></ol></li></ol><p>代码演示：</p><ol><li><strong>总结：文件流这部分还是有一些东西的，新手理解起来可能有些困难，没办法，用的多了就好了。其实常用的就那么几点。</strong></li></ol><h4 id="内存之中对于字符串的操作（sstream）"><a href="#内存之中对于字符串的操作（sstream）" class="headerlink" title="内存之中对于字符串的操作（sstream）"></a>内存之中对于字符串的操作（sstream）</h4><ol><li>string流介绍：string流可以向string对象写入数据，也可以从string对象读取数据。与文件操作类似，只不过数据交互变成了从内存到内存。</li></ol><p>代码演示：string流默认包含一个string对象，当然，我们也可以指定。</p><ol><li>string流有哪些<ol><li>istringstream从string对象读取数据</li><li>ostringstream向string对象写数据</li><li>stringstream既可以从string对象读取数据，也可以向string对象写数据</li></ol></li><li>string流对象继承自iostream对象，除了继承得来的操作，string流对象还有自己的成员来管理流相关的string。<ol><li>对于string流，io库是没有像cout，cin这样的自定流对象的。流对象需要我们自己去定义<ol><li>sstream strm：sstream代表一个string流对象的类型，以下同理。strm是一个未绑定的stringstream对象。</li><li>Sstream strm(s)：strm是一个绑定了s的拷贝的string流对象。s是一个string对象</li></ol></li><li>strm.str()：返回strm所保存的string的拷贝。</li><li>strm.str(s)：将s拷贝到strm中，返回void</li></ol></li><li>string流对象的作用<ol><li><strong>对数据类型进行转化，也就是string和其它类型的转化，这是string流对象最重要的功能。</strong><ol><li>string转化为int等类型。</li></ol></li></ol></li></ol><p><strong>代码演示：</strong></p><ul><li><ul><li><ol><li>int等类型转化为string。</li></ol></li></ul></li></ul><p><strong>代码演示：</strong></p><ul><li><ol><li>用于对空格分隔的字符串的切分，</li></ol></li></ul><p><strong>代码演示：</strong></p><h2 id="Part8：多线程"><a href="#Part8：多线程" class="headerlink" title="Part8：多线程"></a>Part8：多线程</h2><p><strong>注意：多线程的东西其实有很多，这门课只讲常用的部分，把这些学会基本就够用了。</strong></p><h4 id="多线程基本概念介绍"><a href="#多线程基本概念介绍" class="headerlink" title="多线程基本概念介绍"></a>多线程基本概念介绍</h4><ol><li><strong>多线程的重要性：</strong><ol><li>对于一个专业的C++开发来说，多线程是必须掌握的模块。</li><li>现代程序都是多线程程序了。因为单核处理器的性能早已经达到了瓶颈，只能往多核方向发展。现代的个人计算机都是4核起步，工作站，服务器就更不用说了。</li><li>工作站可以理解为处理能力更强的大型个人计算机，常见的12核，16核。服务器有48核的，甚至更多。</li><li>对于一个计算机来说，是不是说核越多好呢？不是，多核会导致单核的工作性能下降。当核数多到一定程度后，反而总体运行效率下降了。不过，这并不影响现代计算机核数越来越多的趋势。</li><li>传统的单线程程序同时只能在一个核上运行，这是不是太浪费资源了。计算机有8个核，你就用了一个，暴殄天物啊。多线程程序可以使用多个核，极大提高程序运行效率。现在网络通信，音频，视频，游戏服务都是多线程程序。</li></ol></li><li><strong>并发与并行的概念介绍：</strong><ol><li>一句话来说：并行是同时在不同的处理器上处理不同的任务，并发是“同时”在一个处理器上处理多个任务。</li></ol></li></ol><p>解释一下：</p><ul><li><ul><li><ol><li>并行是指有多个处理器。每个处理器各执行一个线程，互不抢占cpu资源，如果线程数量多于CPU，也没有办法，只能将处理器的时间划分为多个时间段，再将时间段分配给各个线程。</li><li>并发是指只有一个处理器，但多个线程被轮换快速执行，使得宏观上有了同时执行的效果。作用原理是将单处理器的时间划分为多个时间段，再分配给不同的线程。同一时间段只能有一个线程在运行，其它线程均处于挂起状态。</li></ol></li></ul></li></ul><ol><li><strong>进程的概念：</strong><ol><li>进程的概念在面向进程设计的操作系统（就是unix，也包括后面衍生出的linux，mac）和面向线程设计的操作系统（说的就是windows）上有很大区别，两种设计方式的共同点与不同点还是需要理解的。<ol><li>进程是计算机中的程序对某些数据集合的一次运行活动，是系统进行资源分配和调度的最基本单位，是操作系统的结构基础。再用大白话说一遍，一个可执行程序执行起来，就是一个进程。当然，一个程序要执行起来需要各种资源，这些资源就是数据集合。</li><li>在面向进程设计的计算机结构中，进程是程序的基本执行单位，进程包括程序执行的所有资源，同时自己也可以执行。</li><li>在面向线程设计的计算机结构中，线程才是程序的基本执行单位，进程不过是线程的容器罢了。进程就像一个仓库，里面存放了程序的所有资源，进程中的线程才是真正执行程序的单元。</li></ol></li></ol></li><li><strong>线程的概念：</strong><ol><li>linux的线程和windows的线程还是有很大区别的。</li><li>linux的线程就是一种轻量级的进程，只有依靠进程才可以存在。也模拟出了windows线程的方式，让线程成为真正的执行单元。</li><li>windows的线程就简单多了，真正执行程序的最小单元。</li></ol></li><li><strong>总结：</strong><br>说了这么多：其实对进程，线程只是个介绍，这里面水很深。而且windows多线程和linux多线程的区别并不影响我们学习C++11的多线程，C++标准任何平台通用。</li></ol><p><strong>现代C++程序，C++11的多线程功能才是主流，C++11的多线程就是windows模式的，进程为一个仓库，线程才是程序执行的最小单元。linux同样完美支持了这些功能。</strong></p><h4 id="（-）线程的创建"><a href="#（-）线程的创建" class="headerlink" title="（*）线程的创建"></a>（*）线程的创建</h4><ol><li>主线程介绍：一个程序执行起来就是一个进程。而main函数就是主线程，一旦主线程执行完毕，主线程结束，整个进程就会结束。</li><li>子线程介绍：在一个线程执行时，我们可以创建出另外一个线程。两个线程各自执行，互补干涉。注意，当主线程执行完毕，就会强制结束所有子线程，然后进程结束，从这个角度来说，可以认为子线程是主线程的辅助线程。<strong>但是要明白主线程和子线程是平级的，只不过主线程执行完毕后会给所有子线程发送一个信号，使所有子线程强制结束。</strong></li><li>子线程的创建方式：很简单，直接使用thread类就可以了。</li></ol><p><strong>代码演示：</strong></p><p><strong>括号中只要是一个可调用对象就没有问题了。</strong></p><ol><li><strong>子线程创建后如果就不管了，那么会出现非常严重的问题。</strong><ol><li>有些子线程负责对部分数据的处理，主线程必须要等到子线程处理完毕才能继续执行，所以join函数就诞生了。</li></ol></li></ol><p><strong>代码演示</strong>：</p><p>使用了join函数后，主线程就会处于挂起状态，直到子线程执行完毕才可以继续执行。</p><ul><li><ol><li>有些子线程和主线程完全分离，各自执行各自的。但主线程执行完毕，<strong>子线程就会立马被强制结束，容易导致各种bug，查都不知道从哪里开始查。</strong>于是deatch函数就诞生了。</li></ol></li></ul><p><strong>代码演示：</strong></p><p>detach()函数可以让<strong>子线程被C++运行库接管</strong>，就算主线程执行完毕，子线程也会由C++运行时库清理相关资源。保证不会出现各种意想不到的bug。</p><h4 id="（-）传递线程参数"><a href="#（-）传递线程参数" class="headerlink" title="（*）传递线程参数"></a>（*）传递线程参数</h4><ol><li>传递子线程函数的参数：直接传递即可，注意：传递参数分为三种方式，值传递，引用传递，指针传递。</li></ol><p>代码演示：</p><ol><li>传递参数注意事项：<ol><li>在使用detach时不要传递指针，或者说在设置子线程函数时，不要设置指针参数。因为值传递和引用传递并未直接传递地址，而指针传递却直接传递地址。所以当使用deatch时，传指针就会导致错误，指针已经被系统回收，所以不要千万不要传指针。</li></ol></li></ol><p><strong>代码演示：</strong></p><ul><li><ol><li><strong>在使用detach时不要使用隐式类型转化，因为很有可能子线程参数还没来的及将参数转化为自己的类型，主线程就已经执行完毕了。</strong></li></ol></li></ul><ol><li><strong>总结：</strong><ol><li><strong>普通类型在传递子线程函数参数时，直接值传递即可。</strong></li><li><strong>类类型传递引用就可以了，类类型传递引用会首先调用一次复制构造函数生成一个临时变量，故而导致地址不相同。如果采用值传递，需要两次复制构造函数，开销更大。</strong></li></ol></li><li><strong>std::ref的用法：</strong></li></ol><p>根据刚才的演示，使用普通的引用传递会调用一次复制构造函数，导致函数无法对引用对象进行修改，于是std::ref诞生了，它可以使子线程在传递参数时不再调用复制构造函数。</p><p>代码演示：</p><h4 id="（-）线程id的概念："><a href="#（-）线程id的概念：" class="headerlink" title="（*）线程id的概念："></a>（*）线程id的概念：</h4><ol><li>线程id定义：每个线程都有自己的id，不管是主线程还是子线程都有自己的id。直接使用std::this_thread::get_id()就可以获得当前线程的id。</li></ol><p>代码演示：</p><ol><li>注意：线程是依附于进程存在的，所以不同的进程可以有相同的线程id。</li></ol><p>这一课很简单，但这个知识点不知道往哪里放，就单独拿出来了。</p><h4 id="（-）数据共享与数据保护"><a href="#（-）数据共享与数据保护" class="headerlink" title="（*）数据共享与数据保护"></a>（*）数据共享与数据保护</h4><ol><li>多个线程的执行顺序是乱的，具体执行方法和处理器的调度机制有关系。从开发者的角度讲，就是没有规律的。</li></ol><p>代码演示：</p><ol><li>在讲数据保护问题之前，为了帮助大家理解数据保护问题，这里额外扩展一些关于汇编的知识。科班的同学应该很熟悉，给非科班的人介绍一下。</li></ol><p>一个进程运行时，数据存储在内存中。如果一个数据要进行运算，必须先将数据拷贝到寄存器中。比如要对栈上的一个int i进行“++”操作，需要将i的值拷贝到寄存器中，将该值自加后再拷贝到原来的内存。</p><p>如果此时有两个线程均进行的是这样的操作，可能出现两个进程都拷贝了i原来的值到寄存器，然后各种加一，再拷贝到i对应内存的情况，最终导致i这个变量只自加了一次。</p><p>这是同时写数据的情况，那么一读一写呢？这也是有问题的，谁知道读数据时写数据步骤已经到了哪里，谁知道读出来的是个什么东西。</p><ol><li>数据保护问题：<ol><li>数据保护问题总共有三种情况：<ol><li>至少两个线程对共享数据均进行读操作，完全不会出现数据安全问题。</li><li>至少两个线程对共享数据均进行写操作，会出现数据安全问题，需要数据保护。</li><li>至少两个线程对共享数据有的进行读，有的进行写，也会出现数据安全问题，需要进行数据保护。</li></ol></li></ol></li></ol><p>代码演示：</p><p>数据保护的方法一共就两种：互斥锁，原子操作。</p><ol><li><strong>互斥锁：</strong><ol><li>互斥锁的作用原理很简单，对共享数据加锁，当一个线程对这块数据进行操作时，别的线程就无法对该区域数据进行操作。</li></ol></li></ol><p>代码演示：</p><ul><li><ol><li>这种方式的互斥锁有个弊端，就是lock()之后容易忘记unlock()，就和指针类似。于是和智能指针类似，也有了lock_guard，用来防止开发人员忘了解锁。</li></ol></li></ul><p>代码演示：</p><ol><li>原子操作：（使用频率远远不及互斥锁）<ol><li>原子操作的原理：将一个数据设置为原子状态，使得该数据处于无法被分割的状态，意思就是处理器在处理被设置为原子状态的数据时，其它处理器无法处理该段数据，该处理器也会保证在处理完该数据之前不会处理其他数据。</li></ol></li></ol><p>代码演示：</p><p>总结：在编写多线程代码时，数据保护是一个必须考虑，非常常用的功能。互斥锁的使用频率是远远高于原子操作，原子操作看似简单，但当需要保护的数据很多时，就会极其复杂。</p><p><strong>所以：对于单个数据，可以使用原子操作，其它的使用互斥锁就可以了。</strong></p><h4 id="（-）死锁"><a href="#（-）死锁" class="headerlink" title="（*）死锁"></a>（*）死锁</h4><p>死锁就像两个人在互相等对方。A说，等B来了就去B现在所在的地方；B说，等A来了我就去A所在的地方，结果就是A和B都在等对面过来才能去对面。这就导致了一个死循环，放在多线程中，就是死锁。</p><p>举个例子：</p><p>解决方法也很简单。</p><ol><li>只要让两个锁顺序一致就可以了。</li></ol><p><strong>代码演示：</strong></p><ol><li>但是让两个锁顺序一致常常是说起来容易，做起来难。于是C++11提供了std::lock。这个模板可以保证多个互斥锁绝对不会出现死锁的问题。同时提供了std::adopt_lock的功能来避免忘记释放锁的问题。</li></ol><p><strong>总结：死锁是一个比较常见的bug，面试时也经常询问死锁相关的知识。</strong></p><p>这一节课上完，多线程的主体部分就讲完了，后面都是使用频率较低的东西，也就是个补充。所以前六节课必须学会，每一课都是重点。后面的我就不讲了。</p><h2 id="Part9：异常处理"><a href="#Part9：异常处理" class="headerlink" title="Part9：异常处理"></a>Part9：异常处理</h2><p><strong>异常处理的前情提要：很多人不喜欢使用异常处理，认为它麻烦，应对可能出现的错误要写那么多代码，会非常麻烦。</strong></p><p><strong>但实际上不是这样的，我们只需要在一些开发人员难以控制，比较容易出错的地方对异常进行处理就可以了，需要进行异常处理的地方并不多。</strong></p><p>举几个例子。</p><ol><li>接收传递过来的被除数，我们难以判断被除数是否为0，此时异常处理就很有意义了。</li><li>接收文件名，如果文件不存在，我们可以按照之前的写法要求重发一遍，也可以直接报异常，异常就是文件不存在。</li><li>我们在动态分配内存时，经常出现内存不足的情况（在大型程序中，这是非常常见）。比如我们需要动态分配一个未知大小的数组，数组大小等待传入。使用new操作符会直接抛出bad_alloc的异常。</li></ol><p>对new的处理非常重要，大家如果做专业的C++开发，会经常用到。</p><p>此外使用智能指针时如果内存分配不够也会抛出bad_alloc的异常</p><ol><li>有个vector，我们需要接受一个参数，然后取出参数对应的数组元素。此时就经常出现数组的越界问题。</li></ol><p><strong>最常用的基本就这些例子了，剩下的也都和这些类似。</strong></p><p><strong>异常处理这一章东西不多，一会儿把这些例子演示一下就可以了。</strong></p><h4 id="异常处理的介绍："><a href="#异常处理的介绍：" class="headerlink" title="异常处理的介绍："></a>异常处理的介绍：</h4><ol><li><strong>异常是程序在执行期间产生的问题（编译期出现的错误在写代码时开发环境就有提示）</strong>。C++的异常是指程序运行时发生的特殊情况。</li><li>异常提供了一种转移程序控制权的方式。C++的异常处理涉及到三个关键字：try，catch，throw。<ol><li>throw：当问题出现时，程序会抛出一个异常。这是通过throw关键字来完成的。</li><li>catch：在你想要处理问题的地方，通过异常处理程序捕获异常。catch关键字用于捕获异常。</li><li>try：try块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个catch块。</li></ol></li></ol><p>如果有一个块抛出一个异常，捕获异常的方法会使用try和catch关键字。try块中放可能抛出异常的代码，try块中的代码被称为保护代码。常见的异常处理格式如图所示。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66ba0139d9c307b7e92e2831.png" alt="code"></p><ol><li>抛出异常：throw语句可以在代码块的任何地方抛出异常，throw抛出的表达式的结果决定了抛出的异常的类型。</li></ol><p>代码演示：</p><h4 id="C-的标准异常"><a href="#C-的标准异常" class="headerlink" title="C++的标准异常"></a>C++的标准异常</h4><ol><li>C++提供了一系列标准的异常，定义在头文件“<exception>”中，它们是以父子层次结构组织起来的，如下图所示。</exception></li></ol><p><strong>图只要有个大致印象就可以了， 不需要全背住</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66ba0139d9c307b7e92e2823.jpg" alt="code"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66ba0139d9c307b7e92e280d.png" alt="code"></p><ol><li>别看图很复杂，异常种类有很多，但经常使用的其实就几个。<ol><li>bad_alloc错误，使用new分配内存失败就会抛出bad_alloc错误。</li><li>out_of_range错误，在使用at时，容器越界就会抛出这个错误，这也是“at”比“[]”更加优秀的原因。</li><li>runtime_error错误，运行时错误，只有在程序运行时才能检测到的错误。这是一个相对的概念，和logic_error形成对比。logic_error可以读代码读出来，runtime_error就不行。</li></ol></li></ol><p>我们也经常将一些读代码无法判断的异常标识为runtime_error。</p><ul><li><ol><li>... 错误，可以接受任何错误，我们一般都会在catch最后加上“...”，这样就可以接受所有类型的异常了。</li></ol></li></ul><p><strong>代码演示:</strong></p><p><strong>剩下的异常，我也用代码演示一下，这些异常使用频率比较低，但在某些情况下也是需要使用的。</strong></p><ol><li>自定义异常类型，其实需要自定义异常类型的情况真的非常少，这里就不介绍了，其实和标准异常也是一样的。</li></ol><h2 id="Part10：各种难以归类但有使用价值的知识点"><a href="#Part10：各种难以归类但有使用价值的知识点" class="headerlink" title="Part10：各种难以归类但有使用价值的知识点"></a>Part10：各种难以归类但有使用价值的知识点</h2><h4 id="万能引用与引用折叠"><a href="#万能引用与引用折叠" class="headerlink" title="万能引用与引用折叠"></a>万能引用与引用折叠</h4><ol><li>万能引用的概念：<ol><li>C++11除了带来了右值引用，还带来了万能引用，也就是既能当做左值，又能当做右值的引用。</li></ol></li></ol><p>注意：万能引用是既可以被编译期处理为左值引用，又可以被编译期处理为右值引用。<strong>不是既是左值引用又是右值引用，不违背C++一个引用不是左值引用，就是右值引用的基本说法，万能引用会在编译期被当做左值引用或右值引用处理。</strong></p><ol><li>万能引用的格式：万能引用的格式有两种<ol><li>模板型：</li></ol></li></ol><p>template<typename t></typename></p><p>void func(T&amp;&amp; parm)</p><p>代码演示：</p><p><strong>这个T&amp;&amp; 就是万能引用类型。</strong></p><p><strong>注意：只有T&amp;&amp; 是万能引用类型</strong></p><p><strong>以下的写法均不是万能引用：</strong></p><p><strong>const T&amp;&amp; parm 这就是普通的右值引用。</strong></p><p><strong>vector<t>&amp;&amp; parm 这也是右值引用。</t></strong></p><p><strong>template<typename t></typename></strong></p><p><strong>class MyVector<br>｛</strong></p><p><strong>public:</strong></p><p><strong>void push_back(T&amp;&amp; elem)</strong></p><p><strong>｝</strong></p><p><strong>注意：此时T&amp;&amp; 不是万能引用，因为T影响的是MyVector的类型。</strong></p><p><strong>只有这样写，才是万能引用。</strong></p><p><strong>template<typename t></typename></strong></p><p><strong>class MyVector<br>｛</strong></p><p><strong>public:</strong></p><p><strong>template<typename t2></typename></strong></p><p><strong>void push_back(T2&amp;&amp; elem)</strong></p><p><strong>｝</strong></p><p><strong>此时T2&amp;&amp; 的类型完全独立于MyVector类了，每调用一次push_back函数，都要推断T2的类型。</strong></p><ul><li><ol><li>auto型：</li></ol></li></ul><p>auto &amp;&amp; var = var2；</p><p><strong>代码演示：</strong></p><p>这个auto&amp;&amp; 就是万能引用。</p><p><strong>const auto&amp;&amp; var 就不是万能引用了。</strong></p><ol><li>万能引用的作用，就是当参数为左值时。T&amp;&amp;为左值。当参数为右值时，T&amp;&amp; 为右值。就这么简单。</li></ol><p><strong>代码演示：</strong></p><ol><li>引用折叠：引用折叠其实概念很简单</li></ol><p>一个引用不是左值引用就是右值引用，当一个万能引用被认为左值引用时，类型应该是T&amp; &amp;&amp;，此时类型就会折叠为T&amp;。</p><p>简单来说，就是引用符号太多了，折叠为“&amp;”或“&amp;&amp;”</p><p><strong>看代码：</strong></p><h4 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h4><ol><li>C++完美转发的定义：完美转发是什么呢？说到底，它描述的其实就是一个参数传递的过程，能够将一个传递到一个函数的参数，再通过该函数原封不动的传递给另一个函数（<strong>这里的原封不动不单是指参数的值，更包括参数的类型，参数的限定符</strong>）</li></ol><p>光用语言描述确实描述不清楚，所以。</p><p><strong>代码演示：</strong></p><ol><li>我们发现以前的传递参数的方法都无法在万能引用中解决完美转发的问题。</li></ol><p><strong>代码演示：</strong></p><ol><li>于是C++提供了forward模板来解决完美转发的问题，forward模板可以使参数推断出它原来的类型，实现了完美转发。</li><li><strong>总结：完美转发就是一个专门配合万能引用的知识点，专门用来在使用万能引用的地方原封不动的传递参数。其实记住它是和万能引用配合使用的就掌握的差不多了，</strong></li></ol><p><strong>最后再说一点，其实Part10原本还是打算讲一些东西的，后来想了想，这些都是比较复杂的东西了，新手根本用不到，用的到的人也都是一些老家伙了，完全有了自己查找资料的能力，所以像萃取这种知识就没有讲。</strong></p><p><strong>这些东西，绝对够新手看了，非常的全，也非常实用。</strong></p><h2 id="附页1：STL全部的算法"><a href="#附页1：STL全部的算法" class="headerlink" title="附页1：STL全部的算法"></a>附页1：STL全部的算法</h2><p><strong>注意：我这个文档的主要功能还是给STL的算法分个类，要查看算法严格的描述，还是去微软官网查看吧，官方文档又准又全。</strong></p><h4 id="lt-一-gt-查找算法-13个-：判断容器中是否包含某个值"><a href="#lt-一-gt-查找算法-13个-：判断容器中是否包含某个值" class="headerlink" title="&lt;一&gt;查找算法(13个)：判断容器中是否包含某个值"></a>&lt;一&gt;查找算法(13个)：判断容器中是否包含某个值</h4><h5 id="adjacent-find"><a href="#adjacent-find" class="headerlink" title="adjacent_find:"></a>adjacent_find:</h5><p>在iterator对标识元素范围内，查找一对相邻重复元素，找到则返回指向这对元素的第一个元素forwardIterator。否则返回最后一个元素的forwardIterator。</p><h5 id="binary-search"><a href="#binary-search" class="headerlink" title="binary_search:"></a>binary_search:</h5><p>在有序序列中查找value，找到返回true。重载的版本实用指定的比较函数对象或函数指针来判断相等。</p><h5 id="count"><a href="#count" class="headerlink" title="count:"></a>count:</h5><p>利用等于操作符，把标志范围内的元素与输入值比较，返回相等元素个数。</p><h5 id="count-if"><a href="#count-if" class="headerlink" title="count_if:"></a>count_if:</h5><p>利用输入的操作符，对标志范围内的元素进行操作，返回结果为true的个数。</p><h5 id="equal-range"><a href="#equal-range" class="headerlink" title="equal_range:"></a>equal_range:</h5><p><strong>注意，必须对有序容器进查找，下面的lower_bound和upper_bound也是同理。</strong></p><p>功能类似equal，返回一对iterator，第一个表示lower_bound，第二个表示upper_bound。</p><p>find利用底层元素的等于操作符，对指定范围内的元素与输入值进行比较。当匹配时，结束搜索，返回该元素的一个InputIterator。</p><h5 id="find-end"><a href="#find-end" class="headerlink" title="find_end:"></a>find_end:</h5><p>在指定范围内查找”由输入的另外一对iterator标志的第二个序列”的最后一次出现。找到则返回最后一对的第一个迭代器，否则返回输入的”另外一对”的第一个迭代器。重载版本使用用户输入的操作符代替等于操作。</p><h5 id="find-first-of"><a href="#find-first-of" class="headerlink" title="find_first_of:"></a>find_first_of:</h5><p>在指定范围内查找”由输入的另外一对iterator标志的第二个序列”中任意一个元素的第一次出现。重载版本中使用了用户自定义操作符。</p><h5 id="find-if"><a href="#find-if" class="headerlink" title="find_if:"></a>find_if:</h5><p>使用输入的函数代替等于操作符执行find。</p><h5 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower_bound:"></a>lower_bound:</h5><p>返回一个iterator，指向在有序序列范围内的可以插入指定值而不破坏容器顺序的第一个位置。重载函数使用自定义比较操作。</p><h5 id="upper-bound"><a href="#upper-bound" class="headerlink" title="upper_bound:"></a>upper_bound:</h5><p>返回一个iterator，指向在有序序列范围内插入value而不破坏容器顺序的最后一个位置，该位置标志一个大于value的值。重载函数使用自定义比较操作。</p><h5 id="search"><a href="#search" class="headerlink" title="search:"></a>search:</h5><p><strong>这两个是真的不好描述，去微软官网查看一下吧，简单，比我在这里总结的强多了。</strong></p><p>search_n:</p><h4 id="lt-二-gt-排序和通用算法-14个-：提供元素排序策略"><a href="#lt-二-gt-排序和通用算法-14个-：提供元素排序策略" class="headerlink" title="&lt;二&gt;排序和通用算法(14个)：提供元素排序策略"></a>&lt;二&gt;排序和通用算法(14个)：提供元素排序策略</h4><h5 id="inplace-merge"><a href="#inplace-merge" class="headerlink" title="inplace_merge:"></a>inplace_merge:</h5><h5 id="merge"><a href="#merge" class="headerlink" title="merge:"></a>merge:</h5><h5 id="nth-element"><a href="#nth-element" class="headerlink" title="nth_element:"></a>nth_element:</h5><h5 id="partial-sort"><a href="#partial-sort" class="headerlink" title="partial_sort:"></a>partial_sort:</h5><h5 id="partial-sort-copy"><a href="#partial-sort-copy" class="headerlink" title="partial_sort_copy:"></a>partial_sort_copy:</h5><h5 id="partition"><a href="#partition" class="headerlink" title="partition:"></a>partition:</h5><h5 id="random-shuffle"><a href="#random-shuffle" class="headerlink" title="random_shuffle:"></a>random_shuffle:</h5><h5 id="reverse"><a href="#reverse" class="headerlink" title="reverse:"></a>reverse:</h5><h5 id="reverse-copy"><a href="#reverse-copy" class="headerlink" title="reverse_copy:"></a>reverse_copy:</h5><h5 id="rotate"><a href="#rotate" class="headerlink" title="rotate:"></a>rotate:</h5><h5 id="rotate-copy"><a href="#rotate-copy" class="headerlink" title="rotate_copy:"></a>rotate_copy:</h5><h5 id="sort"><a href="#sort" class="headerlink" title="sort:"></a>sort:</h5><h5 id="stable-sort"><a href="#stable-sort" class="headerlink" title="stable_sort:"></a>stable_sort:</h5><h5 id="stable-partition"><a href="#stable-partition" class="headerlink" title="stable_partition:"></a>stable_partition:</h5><h4 id="lt-三-gt-删除算法-15个"><a href="#lt-三-gt-删除算法-15个" class="headerlink" title="&lt;三&gt;删除算法(15个)"></a>&lt;三&gt;删除算法(15个)</h4><h5 id="copy"><a href="#copy" class="headerlink" title="copy:"></a>copy:</h5><h5 id="copy-backward"><a href="#copy-backward" class="headerlink" title="copy_backward:"></a>copy_backward:</h5><h5 id="iter-swap"><a href="#iter-swap" class="headerlink" title="iter_swap:"></a>iter_swap:</h5><h5 id="remove"><a href="#remove" class="headerlink" title="remove:"></a>remove:</h5><h5 id="remove-copy"><a href="#remove-copy" class="headerlink" title="remove_copy:"></a>remove_copy:</h5><h5 id="remove-if"><a href="#remove-if" class="headerlink" title="remove_if:"></a>remove_if:</h5><h5 id="remove-copy-if"><a href="#remove-copy-if" class="headerlink" title="remove_copy_if:"></a>remove_copy_if:</h5><h5 id="replace"><a href="#replace" class="headerlink" title="replace:"></a>replace:</h5><h5 id="replace-copy"><a href="#replace-copy" class="headerlink" title="replace_copy:"></a>replace_copy:</h5><h5 id="replace-if"><a href="#replace-if" class="headerlink" title="replace_if:"></a>replace_if:</h5><h5 id="replace-copy-if"><a href="#replace-copy-if" class="headerlink" title="replace_copy_if:"></a>replace_copy_if:</h5><h5 id="swap"><a href="#swap" class="headerlink" title="swap:"></a>swap:</h5><h5 id="swap-range"><a href="#swap-range" class="headerlink" title="swap_range:"></a>swap_range:</h5><h5 id="unique"><a href="#unique" class="headerlink" title="unique:"></a>unique:</h5><h5 id="unique-copy"><a href="#unique-copy" class="headerlink" title="unique_copy:"></a>unique_copy:</h5><h4 id="lt-四-gt-排列组合算法-2个-：提供计算给定集合按一定顺序的所有可能排列组合"><a href="#lt-四-gt-排列组合算法-2个-：提供计算给定集合按一定顺序的所有可能排列组合" class="headerlink" title="&lt;四&gt;排列组合算法(2个)：提供计算给定集合按一定顺序的所有可能排列组合"></a>&lt;四&gt;排列组合算法(2个)：提供计算给定集合按一定顺序的所有可能排列组合</h4><h5 id="next-permutation"><a href="#next-permutation" class="headerlink" title="next_permutation:"></a>next_permutation:</h5><h5 id="prev-permutation"><a href="#prev-permutation" class="headerlink" title="prev_permutation:"></a>prev_permutation:</h5><h4 id="lt-五-gt-算术算法-4个"><a href="#lt-五-gt-算术算法-4个" class="headerlink" title="&lt;五&gt;算术算法(4个)"></a>&lt;五&gt;算术算法(4个)</h4><h5 id="accumulate"><a href="#accumulate" class="headerlink" title="accumulate:"></a>accumulate:</h5><h5 id="partial-sum"><a href="#partial-sum" class="headerlink" title="partial_sum:"></a>partial_sum:</h5><h5 id="inner-product"><a href="#inner-product" class="headerlink" title="inner_product:"></a>inner_product:</h5><h5 id="adjacent-difference"><a href="#adjacent-difference" class="headerlink" title="adjacent_difference:"></a>adjacent_difference:</h5><h4 id="lt-六-gt-生成和异变算法-6个"><a href="#lt-六-gt-生成和异变算法-6个" class="headerlink" title="&lt;六&gt;生成和异变算法(6个)"></a>&lt;六&gt;生成和异变算法(6个)</h4><h5 id="fill"><a href="#fill" class="headerlink" title="fill:"></a>fill:</h5><h5 id="fill-n"><a href="#fill-n" class="headerlink" title="fill_n:"></a>fill_n:</h5><h5 id="for-each"><a href="#for-each" class="headerlink" title="for_each:"></a>for_each:</h5><h5 id="generate"><a href="#generate" class="headerlink" title="generate:"></a>generate:</h5><h5 id="generate-n"><a href="#generate-n" class="headerlink" title="generate_n:"></a>generate_n:</h5><h5 id="transform"><a href="#transform" class="headerlink" title="transform:"></a>transform:</h5><h4 id="lt-七-gt-关系算法-8个"><a href="#lt-七-gt-关系算法-8个" class="headerlink" title="&lt;七&gt;关系算法(8个)"></a>&lt;七&gt;关系算法(8个)</h4><h5 id="equal"><a href="#equal" class="headerlink" title="equal:"></a>equal:</h5><h5 id="includes"><a href="#includes" class="headerlink" title="includes:"></a>includes:</h5><h5 id="lexicographical-compare"><a href="#lexicographical-compare" class="headerlink" title="lexicographical_compare:"></a>lexicographical_compare:</h5><h5 id="max"><a href="#max" class="headerlink" title="max:"></a>max:</h5><h5 id="max-element"><a href="#max-element" class="headerlink" title="max_element:"></a>max_element:</h5><h5 id="min"><a href="#min" class="headerlink" title="min:"></a>min:</h5><h5 id="min-element"><a href="#min-element" class="headerlink" title="min_element:"></a>min_element:</h5><h5 id="mismatch"><a href="#mismatch" class="headerlink" title="mismatch:"></a>mismatch:</h5><h4 id="lt-八-gt-集合算法-4个"><a href="#lt-八-gt-集合算法-4个" class="headerlink" title="&lt;八&gt;集合算法(4个)"></a>&lt;八&gt;集合算法(4个)</h4><h5 id="set-union"><a href="#set-union" class="headerlink" title="set_union:"></a>set_union:</h5><h5 id="set-intersection"><a href="#set-intersection" class="headerlink" title="set_intersection:"></a>set_intersection:</h5><h5 id="set-difference"><a href="#set-difference" class="headerlink" title="set_difference:"></a>set_difference:</h5><h5 id="set-symmetric-difference"><a href="#set-symmetric-difference" class="headerlink" title="set_symmetric_difference:"></a>set_symmetric_difference:</h5><h4 id="lt-九-gt-堆算法-4个"><a href="#lt-九-gt-堆算法-4个" class="headerlink" title="&lt;九&gt;堆算法(4个)"></a>&lt;九&gt;堆算法(4个)</h4><h5 id="make-heap"><a href="#make-heap" class="headerlink" title="make_heap:"></a>make_heap:</h5><h5 id="pop-heap"><a href="#pop-heap" class="headerlink" title="pop_heap:"></a>pop_heap:</h5><h5 id="push-heap"><a href="#push-heap" class="headerlink" title="push_heap:"></a>push_heap:</h5><h5 id="sort-heap"><a href="#sort-heap" class="headerlink" title="sort_heap:"></a>sort_heap:</h5><h2 id="附页2：STL标准库提供的仿函数"><a href="#附页2：STL标准库提供的仿函数" class="headerlink" title="附页2：STL标准库提供的仿函数"></a>附页2：STL标准库提供的仿函数</h2><h4 id="算术类仿函数"><a href="#算术类仿函数" class="headerlink" title="算术类仿函数"></a>算术类仿函数</h4><h5 id="加："><a href="#加：" class="headerlink" title="加："></a>加：</h5><p>plus<t></t></p><h5 id="减："><a href="#减：" class="headerlink" title="减："></a>减：</h5><p>minus<t></t></p><h5 id="乘："><a href="#乘：" class="headerlink" title="乘："></a>乘：</h5><p>multiplies<t></t></p><h5 id="除："><a href="#除：" class="headerlink" title="除："></a>除：</h5><p>divides<t></t></p><h5 id="模取："><a href="#模取：" class="headerlink" title="模取："></a>模取：</h5><p>modulus<t></t></p><h5 id="取负："><a href="#取负：" class="headerlink" title="取负："></a>取负：</h5><p>negate<t></t></p><h4 id="关系运算类仿函数"><a href="#关系运算类仿函数" class="headerlink" title="关系运算类仿函数"></a>关系运算类仿函数</h4><h5 id="等于："><a href="#等于：" class="headerlink" title="等于："></a>等于：</h5><p>equal_to<t></t></p><h5 id="不等于："><a href="#不等于：" class="headerlink" title="不等于："></a>不等于：</h5><p>not_equal_to<t></t></p><h5 id="大于："><a href="#大于：" class="headerlink" title="大于："></a>大于：</h5><p>greater<t></t></p><h5 id="大于等于："><a href="#大于等于：" class="headerlink" title="大于等于："></a>大于等于：</h5><p>greater_equal<t></t></p><h5 id="小于："><a href="#小于：" class="headerlink" title="小于："></a>小于：</h5><p>less<t></t></p><h5 id="小于等于："><a href="#小于等于：" class="headerlink" title="小于等于："></a>小于等于：</h5><p>less_equal<t></t></p><h4 id="逻辑运算仿函数"><a href="#逻辑运算仿函数" class="headerlink" title="逻辑运算仿函数"></a>逻辑运算仿函数</h4><h5 id="逻辑与："><a href="#逻辑与：" class="headerlink" title="逻辑与："></a>逻辑与：</h5><p>logical_and<t></t></p><h5 id="逻辑或："><a href="#逻辑或：" class="headerlink" title="逻辑或："></a>逻辑或：</h5><p>logical_or<t></t></p><h5 id="逻辑否："><a href="#逻辑否：" class="headerlink" title="逻辑否："></a>逻辑否：</h5><p>logical_no<t></t></p><h2 id="附页3：STL各种容器的操作："><a href="#附页3：STL各种容器的操作：" class="headerlink" title="附页3：STL各种容器的操作："></a>附页3：STL各种容器的操作：</h2><p><strong>注意：</strong></p><ol><li><strong>不需要死记硬背，用的多了自然就会了。</strong></li><li><strong>容器的各种函数最好的方式就是打开vs，函数所有的参数都有显示，看不懂就去微软官网查一查。</strong></li></ol><h4 id="vector的各种函数"><a href="#vector的各种函数" class="headerlink" title="vector的各种函数"></a>vector的各种函数</h4><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><ol><li>vector()：创建一个空的vector</li><li>vector(const std::allocator<t>&amp; al)：使用指定的分配器来分配内存。<strong>allocator就是一个内存分配器，vector已经指定了默认的分配器了，不需要我们去主动调用，以后设计allocator直接忽略就可以了，其实这个构造函数只不过是用指定的分配器去创建一个空的vector罢了。</strong></t></li><li>vector(std::vector<t>&amp;&amp; right, const std::allocator<t>&amp; al)：就是移动构造函数，第二个参数表示我们指定分配器。</t></t></li><li>vector(const std::vector<t>&amp; vec, const std::alloctor<t>&amp; al)：就是复制构造函数，分配器可以自己指定，当然，一般来说，vector默认的分配器就够用了。</t></t></li><li>vector(std::initializer_list<t>&amp; initList, const std::allocator<t>&amp; al)：就是使用initializer_list来初 始化容器，第二个参数表示我们可以指定分配器。</t></t></li><li>vector(iter first, iter last, const std::allocator<t>&amp; al)：就是容器初始有迭代器[first, last)的内容（<strong>这里使用deque，list的迭代器也可以</strong>），第三个参数还是表示我们可以指定分配器。</t></li><li>vector(const size_t count, const std::alloctor<t>&amp; al)：创建一个vector，元素个数为count。元素均为默认值，如果是普通类型，则赋值为0。如果是类类型，则均使用默认构造函数进行初始化。</t></li><li>vector(const size_t count，const T&amp; t)：创建一个vector，元素个数为count，且值均为t。</li></ol><h5 id="增加函数"><a href="#增加函数" class="headerlink" title="增加函数"></a>增加函数</h5><ol><li>void push_back(const T&amp; value)：向容器尾部增加一个元素value。</li><li>void push_back(T&amp;&amp; value)：向容器尾部增加一个元素value，这不过这次以右值引用的形式添加。</li><li>std::vector<t>::iterator insert(std::vector<t>::const_iterator&amp; where, std::initializer_list<t>initList)：在where迭代器指定的地方添加initList，<strong>返回值为指向新添加的第一个元素的迭代器，insert函数虽然有很多重载，但返回值是完全类似的，所以接下来insert函数的返回值就不介绍了。</strong></t></t></t></li><li>std::vector<t>::iterator insert(std::vector<t>::const_iterator&amp; where, iter first, iter last)：将迭代器[first, last)添加到迭代器where指定的位置。</t></t></li><li>std::vector<t>::iterator insert(std::vector<t>::const_iterator&amp; where, size_t count, const int&amp; value)：在where处插入count个value。</t></t></li><li>std::vector<t>::iterator insert(std::vector<t>::const_iterator&amp; where, const T&amp; value)：在where处插入value。</t></t></li><li>std::vector<t>::iterator insert(std::vector<t>::const_iterator&amp; where, T&amp;&amp; value)：在where处插入value，只不过这次以右值引用的形式插入了。</t></t></li></ol><h5 id="删除函数"><a href="#删除函数" class="headerlink" title="删除函数"></a>删除函数</h5><ol><li>std::vector<t>::iterator erase(std::vector<t>::const_iterator where)：删除容器迭代器指向的元素。<strong>返回指向被删除元素后面的那个元素的迭代器。</strong></t></t></li><li>iterator erase(iterator first, iterator last)：删除容器中[first, last)中的元素。<strong>返回指向被删除元素后面的那个元素的迭代器。</strong></li><li>void pvoid op_back()：删除容器中最后一个元素。</li><li>clear()：删除容器中所有元素。</li></ol><h5 id="遍历函数"><a href="#遍历函数" class="headerlink" title="遍历函数"></a>遍历函数</h5><ol><li>T&amp; at(const size_t pos)：返回pos位置元素的引用。</li><li>const T&amp; at(const size_t pos) const：at函数的常量版本。</li><li>T&amp; front()：返回首元素的引用。</li><li>const T&amp; front() const：front函数的常量版本。</li><li>T&amp; back()：返回尾元素的引用。</li><li>const T&amp; back() const：back函数的常量版本。</li><li>std::vector<t>::iterator begin()：返回指向容器第一个元素的迭代器。</t></li><li>std::vector<t>::const_iterator begin() const：begin函数的常量版本。</t></li><li>std::vector<t>::const_iterator cbegin() const：可以主动调用的begin函数的常量版本。</t></li><li>std::vector<t>::iterator end()：返回指向容器最后一个元素的下一个元数的迭代器。</t></li></ol><p>end()函数也有两个常量版本，和begin类似，就不写了。</p><ol><li>std::vector<t>::reverse_iterator rbegin()：反向迭代器，指向最后一个元素。</t></li></ol><p>同样有两个常量版本。</p><ol><li>reverse_iterator rend()：反向迭代器，指向第一个元素之前的元素。</li></ol><p>同样有两个常量版本。</p><h5 id="判断函数"><a href="#判断函数" class="headerlink" title="判断函数"></a>判断函数</h5><ol><li>bool empty() const：判断容器是否为空，若未空，则返回true，否则返回false。</li></ol><h5 id="大小函数"><a href="#大小函数" class="headerlink" title="大小函数"></a>大小函数</h5><ol><li>size_t size() const：返回当前容器中元素的个数。</li><li>size_t capacity() const：返回当前容器不扩张所能容纳的最大元素数量。</li><li>size_t max_size() const：返回当前机器可以存储的元素数量最大值。</li></ol><h5 id="其它函数"><a href="#其它函数" class="headerlink" title="其它函数"></a>其它函数</h5><ol><li>void swap(std::vector<t>&amp; vec)：交换两个同类型容器的的数据。</t></li><li>void assign(int n, const T&amp; x)：将容器设置为n个x。</li><li>void assign(const_iterator first, const iterator last)：将当前容器的元素设置为[first, last)。</li></ol><p>first,last都是迭代器，可以不是vector类型的迭代器，deque，list类型也可以。</p><ol><li>void assign(const std::initialize_list<t>initList)：将容器元素设置为initialize_list的元素。</t></li><li>void res(size_t newSize)：将容器的容量设置为newSIze。</li></ol><h4 id="deque的各种函数："><a href="#deque的各种函数：" class="headerlink" title="deque的各种函数："></a>deque的各种函数：</h4><p>deque的各种函数与vector类似，我就不再重复一遍了。</p><p>这里只介绍vector不同的地方：</p><ol><li>deque支持在容器前面插入删除，操作。也就是支持以下的三个函数<ol><li>void push_front(const T&amp; value）；</li><li>void push_front(T&amp;&amp; value)；</li><li>void pop_front()；</li></ol></li></ol><h4 id="list的各种函数"><a href="#list的各种函数" class="headerlink" title="list的各种函数"></a>list的各种函数</h4><p>list和deque类似，只讲一下和deque不同的部分。list都用支持在前面，后面增加，删除。</p><p>list和deque在函数上的唯一区别就是不支持随机缩影，也<strong>就是不支持at函数</strong>。</p><h4 id="string的各种函数"><a href="#string的各种函数" class="headerlink" title="string的各种函数"></a>string的各种函数</h4><p>string虽然也是顺序容器，但因为本质是对字符串的封装，所以和其它容器在用法上有较大区别。</p><ol><li>获取封装字符串的函数。<ol><li>const char* c_str() const：返回string对象内部的函数的指针<strong>。注意，c_str()函数返回的直接就是string对象内部的指针，也就是说string对象指向的对象发生了改变，返回的对象也会发生改变的。</strong></li></ol></li></ol><p><strong>代码演示一下：</strong></p><ul><li><ol><li>const char* data()const：返回string对象内部的函数指针。和c_str()函数的区别就是返回的字符串后面没有’\0’。</li><li>size_t copy(char* const ptr, size_t count, const size_t off) const：</li></ol></li></ul><p>讲string对象的一部分复制到ptr数组中。</p><p>ptr表示复制到哪个数组。</p><p>count表示复制string对象的几个字符</p><p>off表示从string的哪个字符开始复制。</p><ol><li>字符串比较函数。</li></ol><p>compare函数：这个函数重载比较多，用的时候在vs中查看一下就可以了。可以用string对象的任意部分与另一个字符串进行比较，</p><p>其它函数就和vector类似了，同样支持随机选取，支持容器末尾插入。</p><h4 id="forward-list"><a href="#forward-list" class="headerlink" title="forward_list:"></a>forward_list:</h4><p>和list差不多，只不过是没有size()函数，没有push_back和pop_back函数。</p><h4 id="关联容器的函数和顺序容器有差别的也就那么几个"><a href="#关联容器的函数和顺序容器有差别的也就那么几个" class="headerlink" title="关联容器的函数和顺序容器有差别的也就那么几个"></a>关联容器的函数和顺序容器有差别的也就那么几个</h4><p>在讲map，set时基本已经讲过了，这里就不单独讲了。</p></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>C-CPP学习笔记（3）</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://moonruyan.github.io/post/5dcb4efe.html">https://moonruyan.github.io/post/5dcb4efe.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>梦如烟</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-08-12</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-08-12</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener external nofollow noreferrer" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener external nofollow noreferrer" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><a class="post-meta__tags" href="/tags/C-C/">C/C++</a><a class="post-meta__tags" href="/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">基础语法</a></div><div class="post_share"><div class="social-share" data-image="https://pic.imgdb.cn/item/66ba1490d9c307b7e9497479.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/ac52037f.html" title="弗雷德老爹的餐馆"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66bb048ed9c307b7e9929128.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">弗雷德老爹的餐馆</div></div></a></div><div class="next-post pull-right"><a href="/post/23039749.html" title="【诗词鉴赏】雨霖铃·寒蝉凄切"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66b818e0d9c307b7e9cca75c.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【诗词鉴赏】雨霖铃·寒蝉凄切</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/1c09c678.html" title="C-CPP学习笔记（1）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66b436f5d9c307b7e987fec5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-08</div><div class="title">C-CPP学习笔记（1）</div></div></a></div><div><a href="/post/ebc6996.html" title="C-CPP学习笔记（2）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66b44b5cd9c307b7e9982e42.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-08</div><div class="title">C-CPP学习笔记（2）</div></div></a></div><div><a href="/post/2bd7364a.html" title="C-CPP学习笔记（4）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66c1f502d9c307b7e95d13ba.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-18</div><div class="title">C-CPP学习笔记（4）</div></div></a></div><div><a href="/post/ded2ee12.html" title="嵌入式学习笔记（1）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66a31a77d9c307b7e91bf76c.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-26</div><div class="title">嵌入式学习笔记（1）</div></div></a></div><div><a href="/post/cc6741fc.html" title="嵌入式学习笔记（2）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66a4da35d9c307b7e9aa201d.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-27</div><div class="title">嵌入式学习笔记（2）</div></div></a></div><div><a href="/post/e90c1e20.html" title="嵌入式学习笔记（4）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66acbc94d9c307b7e953a2b9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-02</div><div class="title">嵌入式学习笔记（4）</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Twikoo</span><span id="switch-btn"></span><span class="second-comment">Livere</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div><div><div id="lv-container" data-id="city" data-uid="MTAyMC81OTk4My8zNjQ0Ng"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="author_top is-center"><div class="card-info-avatar"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66937eddd9c307b7e97c8c6f.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-status-box"><div class="author-status"><g-emoji class="g-emoji" alias="palm_tree" fallback-src="https://lskypro.acozycotage.net/LightPicture/2022/12/fe1dc0402e623096.jpg">🐟</g-emoji><span>认真摸鱼中</span></div></div></div><div class="author-info__name">梦如烟</div><div class="author-info__description">一万年太久，只争朝夕</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">63</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/MoonRuYan" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github" style="color:#24292e"></i></a><a class="social-icon" href="https://moonruyan.github.io/image/QQcode.png" target="_blank" title="QQ"><i class="fab fa-qq" style="color:#39f"></i></a><a class="social-icon" href="https://moonruyan.github.io/image/WeChatCode.png" target="_blank" title="WeChat"><i class="fab fa-weixin" style="color:#0c0"></i></a><a class="social-icon" href="mailto:1918730886@qq.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope" style="color:#4a7dbe"></i></a><a class="social-icon" href="https://space.bilibili.com/1025430304" rel="external nofollow noreferrer" target="_blank" title="bilibili"><i class="fa-brands fa-bilibili" style="color:#f9c"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告栏</span></div><div class="announcement_content">Welcome to my blog!</div><div id="welcome-info"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Part1%EF%BC%9A%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D"><span class="toc-text">Part1：课程介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BE%E7%A8%8B%E7%9A%84%E6%80%BB%E4%BD%93%E6%A6%82%E8%BF%B0"><span class="toc-text">课程的总体概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88-%EF%BC%89%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%BB%8B%E7%BB%8D"><span class="toc-text">（*）开发环境介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#vs%E7%9A%84%E4%BB%8B%E7%BB%8D%EF%BC%9A"><span class="toc-text">vs的介绍：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#vs%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD%EF%BC%9A"><span class="toc-text">vs的安装与卸载：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#vs%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8Evs%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="toc-text">vs项目的创建与vs的程序编译过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#vs%E7%9A%84debug%E5%8A%9F%E8%83%BD%E7%AE%80%E4%BB%8B%EF%BC%9A"><span class="toc-text">vs的debug功能简介：</span></a></li></ol></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#Part2%EF%BC%9AC-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="toc-text">Part2：C++的基本特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88-%EF%BC%89%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">（*）程序的执行过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88-%EF%BC%89new%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%8A%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-text">（*）new关键字及内存泄露</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-text">命名空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88-%EF%BC%89C-%E7%9A%84%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AE%80%E4%BB%8B"><span class="toc-text">（*）C++的标准输入输出简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-const%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%8B%E7%BB%8D"><span class="toc-text">4.5. const关键字介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88-%EF%BC%89-auto%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">（**） auto关键字的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88-%EF%BC%89%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%8C%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8"><span class="toc-text">（*）静态变量，指针和引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88-%EF%BC%89%E5%B7%A6%E5%80%BC%EF%BC%8C%E5%8F%B3%E5%80%BC%EF%BC%8C%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%EF%BC%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-text">（**）左值，右值，左值引用，右值引用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC"><span class="toc-text">左值和右值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">引用的分类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88-%EF%BC%89move%E5%87%BD%E6%95%B0%EF%BC%8C%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1"><span class="toc-text">（**）move函数，临时对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#move%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-text">move函数：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%EF%BC%9A"><span class="toc-text">临时对象：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88-%EF%BC%89%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1"><span class="toc-text">（**）可调用对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-text">函数：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%BF%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-text">仿函数：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%9A"><span class="toc-text">lambda表达式：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part3%EF%BC%9A%E7%B1%BB"><span class="toc-text">Part3：类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88-%EF%BC%89%E7%B1%BB%E4%BB%8B%E7%BB%8D%EF%BC%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-text">（*）类介绍，构造函数，析构函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88-%EF%BC%89this%EF%BC%8C%E5%B8%B8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%8E%E5%B8%B8%E5%AF%B9%E8%B1%A1"><span class="toc-text">（*）this，常成员函数与常对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#inline%EF%BC%8Cmutable%EF%BC%8Cdefault%EF%BC%8Cdelete"><span class="toc-text">inline，mutable，default，delete</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E7%B1%BB%E4%B8%8E%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-text">友元类与友元函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88-%EF%BC%89%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">（**）重载运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88-%EF%BC%89%E6%99%AE%E9%80%9A%E7%BB%A7%E6%89%BF%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">（*）普通继承及其实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88-%EF%BC%89%E8%99%9A%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%8Coverride%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">（**）虚函数及其实现原理，override关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0"><span class="toc-text">静态成员变量与静态函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88-%EF%BC%89%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-text">（*）纯虚函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RTTI%EF%BC%9A"><span class="toc-text">RTTI：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-text">多继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E7%BB%A7%E6%89%BF%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">虚继承及其实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88-%EF%BC%89%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">（**）移动构造函数与移动赋值运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part4%EF%BC%9A%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">Part4：智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88-%EF%BC%89%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%A6%82%E8%BF%B0"><span class="toc-text">（*）智能指针概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88-%EF%BC%89shared-ptr"><span class="toc-text">（*）shared_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88-%EF%BC%89weak-ptr"><span class="toc-text">（*）weak_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88-%EF%BC%89unique-ptr"><span class="toc-text">（*）unique_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88-%EF%BC%89%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-text">（**）智能指针的使用范围</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part5%EF%BC%9A%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="toc-text">Part5：模板与泛型编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88-%EF%BC%89%E6%A8%A1%E6%9D%BF%E4%BB%8B%E7%BB%8D%EF%BC%8C%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">（*）模板介绍，类模板与模板实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88-%EF%BC%89initializer-list%E4%B8%8Etypename"><span class="toc-text">（*）initializer_list与typename</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88-%EF%BC%89%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%EF%BC%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-text">（*）函数模板，成员函数模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88-%EF%BC%89%E9%BB%98%E8%AE%A4%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="toc-text">（*）默认模板参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88-%EF%BC%89%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%87%8D%E8%BD%BD%EF%BC%8C%E5%85%A8%E7%89%B9%E5%8C%96%E5%92%8C%E5%81%8F%E7%89%B9%E5%8C%96"><span class="toc-text">（*）模板的重载，全特化和偏特化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part6%EF%BC%9Astl%E6%A0%87%E5%87%86%E5%BA%93"><span class="toc-text">Part6：stl标准库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88-%EF%BC%89stl%E4%BB%8B%E7%BB%8D%E4%B8%8E6%E5%A4%A7%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D"><span class="toc-text">（*）stl介绍与6大模块介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88-%EF%BC%89%E5%AE%B9%E5%99%A8"><span class="toc-text">（*）容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88-%EF%BC%89%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">（*）迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88-%EF%BC%89%E7%AE%97%E6%B3%95"><span class="toc-text">（*）算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-text">仿函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E4%B8%8E%E5%88%86%E9%85%8D%E5%99%A8"><span class="toc-text">适配器与分配器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part7%EF%BC%9Aio%E5%BA%93"><span class="toc-text">Part7：io库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#io%E5%BA%93%E4%BB%8B%E7%BB%8D"><span class="toc-text">io库介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88-%EF%BC%89io%E5%BA%93%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">（*）io库的注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%B8%8E%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E7%9A%84%E4%BA%A4%E4%BA%92%EF%BC%88iostream%EF%BC%89"><span class="toc-text">内存与输入输出设备的交互（iostream）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88-%EF%BC%89%E5%86%85%E5%AD%98%E4%B8%8E%E7%A3%81%E7%9B%98%E7%9A%84%E4%BA%A4%E4%BA%92%EF%BC%88fstream%EF%BC%89"><span class="toc-text">（*）内存与磁盘的交互（fstream）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%B9%8B%E4%B8%AD%E5%AF%B9%E4%BA%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%88sstream%EF%BC%89"><span class="toc-text">内存之中对于字符串的操作（sstream）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part8%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">Part8：多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D"><span class="toc-text">多线程基本概念介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88-%EF%BC%89%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">（*）线程的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88-%EF%BC%89%E4%BC%A0%E9%80%92%E7%BA%BF%E7%A8%8B%E5%8F%82%E6%95%B0"><span class="toc-text">（*）传递线程参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88-%EF%BC%89%E7%BA%BF%E7%A8%8Bid%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-text">（*）线程id的概念：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88-%EF%BC%89%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4"><span class="toc-text">（*）数据共享与数据保护</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88-%EF%BC%89%E6%AD%BB%E9%94%81"><span class="toc-text">（*）死锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part9%EF%BC%9A%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">Part9：异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E4%BB%8B%E7%BB%8D%EF%BC%9A"><span class="toc-text">异常处理的介绍：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E7%9A%84%E6%A0%87%E5%87%86%E5%BC%82%E5%B8%B8"><span class="toc-text">C++的标准异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part10%EF%BC%9A%E5%90%84%E7%A7%8D%E9%9A%BE%E4%BB%A5%E5%BD%92%E7%B1%BB%E4%BD%86%E6%9C%89%E4%BD%BF%E7%94%A8%E4%BB%B7%E5%80%BC%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-text">Part10：各种难以归类但有使用价值的知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8%E4%B8%8E%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0"><span class="toc-text">万能引用与引用折叠</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="toc-text">完美转发</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E9%A1%B51%EF%BC%9ASTL%E5%85%A8%E9%83%A8%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-text">附页1：STL全部的算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lt-%E4%B8%80-gt-%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-13%E4%B8%AA-%EF%BC%9A%E5%88%A4%E6%96%AD%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%9F%90%E4%B8%AA%E5%80%BC"><span class="toc-text">&lt;一&gt;查找算法(13个)：判断容器中是否包含某个值</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#adjacent-find"><span class="toc-text">adjacent_find:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#binary-search"><span class="toc-text">binary_search:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#count"><span class="toc-text">count:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#count-if"><span class="toc-text">count_if:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#equal-range"><span class="toc-text">equal_range:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#find-end"><span class="toc-text">find_end:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#find-first-of"><span class="toc-text">find_first_of:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#find-if"><span class="toc-text">find_if:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#lower-bound"><span class="toc-text">lower_bound:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#upper-bound"><span class="toc-text">upper_bound:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#search"><span class="toc-text">search:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lt-%E4%BA%8C-gt-%E6%8E%92%E5%BA%8F%E5%92%8C%E9%80%9A%E7%94%A8%E7%AE%97%E6%B3%95-14%E4%B8%AA-%EF%BC%9A%E6%8F%90%E4%BE%9B%E5%85%83%E7%B4%A0%E6%8E%92%E5%BA%8F%E7%AD%96%E7%95%A5"><span class="toc-text">&lt;二&gt;排序和通用算法(14个)：提供元素排序策略</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#inplace-merge"><span class="toc-text">inplace_merge:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#merge"><span class="toc-text">merge:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#nth-element"><span class="toc-text">nth_element:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#partial-sort"><span class="toc-text">partial_sort:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#partial-sort-copy"><span class="toc-text">partial_sort_copy:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#partition"><span class="toc-text">partition:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#random-shuffle"><span class="toc-text">random_shuffle:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#reverse"><span class="toc-text">reverse:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#reverse-copy"><span class="toc-text">reverse_copy:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rotate"><span class="toc-text">rotate:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rotate-copy"><span class="toc-text">rotate_copy:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sort"><span class="toc-text">sort:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#stable-sort"><span class="toc-text">stable_sort:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#stable-partition"><span class="toc-text">stable_partition:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lt-%E4%B8%89-gt-%E5%88%A0%E9%99%A4%E7%AE%97%E6%B3%95-15%E4%B8%AA"><span class="toc-text">&lt;三&gt;删除算法(15个)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#copy"><span class="toc-text">copy:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#copy-backward"><span class="toc-text">copy_backward:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#iter-swap"><span class="toc-text">iter_swap:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#remove"><span class="toc-text">remove:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#remove-copy"><span class="toc-text">remove_copy:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#remove-if"><span class="toc-text">remove_if:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#remove-copy-if"><span class="toc-text">remove_copy_if:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#replace"><span class="toc-text">replace:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#replace-copy"><span class="toc-text">replace_copy:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#replace-if"><span class="toc-text">replace_if:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#replace-copy-if"><span class="toc-text">replace_copy_if:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#swap"><span class="toc-text">swap:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#swap-range"><span class="toc-text">swap_range:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#unique"><span class="toc-text">unique:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#unique-copy"><span class="toc-text">unique_copy:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lt-%E5%9B%9B-gt-%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E7%AE%97%E6%B3%95-2%E4%B8%AA-%EF%BC%9A%E6%8F%90%E4%BE%9B%E8%AE%A1%E7%AE%97%E7%BB%99%E5%AE%9A%E9%9B%86%E5%90%88%E6%8C%89%E4%B8%80%E5%AE%9A%E9%A1%BA%E5%BA%8F%E7%9A%84%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88"><span class="toc-text">&lt;四&gt;排列组合算法(2个)：提供计算给定集合按一定顺序的所有可能排列组合</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#next-permutation"><span class="toc-text">next_permutation:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#prev-permutation"><span class="toc-text">prev_permutation:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lt-%E4%BA%94-gt-%E7%AE%97%E6%9C%AF%E7%AE%97%E6%B3%95-4%E4%B8%AA"><span class="toc-text">&lt;五&gt;算术算法(4个)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#accumulate"><span class="toc-text">accumulate:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#partial-sum"><span class="toc-text">partial_sum:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#inner-product"><span class="toc-text">inner_product:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#adjacent-difference"><span class="toc-text">adjacent_difference:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lt-%E5%85%AD-gt-%E7%94%9F%E6%88%90%E5%92%8C%E5%BC%82%E5%8F%98%E7%AE%97%E6%B3%95-6%E4%B8%AA"><span class="toc-text">&lt;六&gt;生成和异变算法(6个)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#fill"><span class="toc-text">fill:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#fill-n"><span class="toc-text">fill_n:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#for-each"><span class="toc-text">for_each:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#generate"><span class="toc-text">generate:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#generate-n"><span class="toc-text">generate_n:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#transform"><span class="toc-text">transform:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lt-%E4%B8%83-gt-%E5%85%B3%E7%B3%BB%E7%AE%97%E6%B3%95-8%E4%B8%AA"><span class="toc-text">&lt;七&gt;关系算法(8个)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#equal"><span class="toc-text">equal:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#includes"><span class="toc-text">includes:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#lexicographical-compare"><span class="toc-text">lexicographical_compare:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#max"><span class="toc-text">max:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#max-element"><span class="toc-text">max_element:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#min"><span class="toc-text">min:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#min-element"><span class="toc-text">min_element:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#mismatch"><span class="toc-text">mismatch:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lt-%E5%85%AB-gt-%E9%9B%86%E5%90%88%E7%AE%97%E6%B3%95-4%E4%B8%AA"><span class="toc-text">&lt;八&gt;集合算法(4个)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#set-union"><span class="toc-text">set_union:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#set-intersection"><span class="toc-text">set_intersection:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#set-difference"><span class="toc-text">set_difference:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#set-symmetric-difference"><span class="toc-text">set_symmetric_difference:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lt-%E4%B9%9D-gt-%E5%A0%86%E7%AE%97%E6%B3%95-4%E4%B8%AA"><span class="toc-text">&lt;九&gt;堆算法(4个)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#make-heap"><span class="toc-text">make_heap:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pop-heap"><span class="toc-text">pop_heap:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#push-heap"><span class="toc-text">push_heap:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sort-heap"><span class="toc-text">sort_heap:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E9%A1%B52%EF%BC%9ASTL%E6%A0%87%E5%87%86%E5%BA%93%E6%8F%90%E4%BE%9B%E7%9A%84%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-text">附页2：STL标准库提供的仿函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E7%B1%BB%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-text">算术类仿函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A0%EF%BC%9A"><span class="toc-text">加：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%8F%EF%BC%9A"><span class="toc-text">减：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%98%EF%BC%9A"><span class="toc-text">乘：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%99%A4%EF%BC%9A"><span class="toc-text">除：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E5%8F%96%EF%BC%9A"><span class="toc-text">模取：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%96%E8%B4%9F%EF%BC%9A"><span class="toc-text">取负：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%B1%BB%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-text">关系运算类仿函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AD%89%E4%BA%8E%EF%BC%9A"><span class="toc-text">等于：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E7%AD%89%E4%BA%8E%EF%BC%9A"><span class="toc-text">不等于：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%A7%E4%BA%8E%EF%BC%9A"><span class="toc-text">大于：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E%EF%BC%9A"><span class="toc-text">大于等于：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E4%BA%8E%EF%BC%9A"><span class="toc-text">小于：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E%EF%BC%9A"><span class="toc-text">小于等于：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-text">逻辑运算仿函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E4%B8%8E%EF%BC%9A"><span class="toc-text">逻辑与：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E6%88%96%EF%BC%9A"><span class="toc-text">逻辑或：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%90%A6%EF%BC%9A"><span class="toc-text">逻辑否：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E9%A1%B53%EF%BC%9ASTL%E5%90%84%E7%A7%8D%E5%AE%B9%E5%99%A8%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="toc-text">附页3：STL各种容器的操作：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#vector%E7%9A%84%E5%90%84%E7%A7%8D%E5%87%BD%E6%95%B0"><span class="toc-text">vector的各种函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E5%87%BD%E6%95%B0"><span class="toc-text">增加函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%87%BD%E6%95%B0"><span class="toc-text">删除函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%87%BD%E6%95%B0"><span class="toc-text">遍历函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%87%BD%E6%95%B0"><span class="toc-text">判断函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E5%87%BD%E6%95%B0"><span class="toc-text">大小函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E5%87%BD%E6%95%B0"><span class="toc-text">其它函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque%E7%9A%84%E5%90%84%E7%A7%8D%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-text">deque的各种函数：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E7%9A%84%E5%90%84%E7%A7%8D%E5%87%BD%E6%95%B0"><span class="toc-text">list的各种函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E7%9A%84%E5%90%84%E7%A7%8D%E5%87%BD%E6%95%B0"><span class="toc-text">string的各种函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#forward-list"><span class="toc-text">forward_list:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E6%9C%89%E5%B7%AE%E5%88%AB%E7%9A%84%E4%B9%9F%E5%B0%B1%E9%82%A3%E4%B9%88%E5%87%A0%E4%B8%AA"><span class="toc-text">关联容器的函数和顺序容器有差别的也就那么几个</span></a></li></ol></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/c24240c6.html" title="博客更新日志2024.10.3"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66fe73e3335a200d6a97376d.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="博客更新日志2024.10.3"></a><div class="content"><a class="title" href="/post/c24240c6.html" title="博客更新日志2024.10.3">博客更新日志2024.10.3</a><time datetime="2024-10-03T10:44:48.000Z" title="发表于 2024-10-03 18:44:48">2024-10-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/a9a6fba5.html" title="《斩服少女》:超越边界的反叛与自由"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66fd2de9f21886ccc00a065c.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="《斩服少女》:超越边界的反叛与自由"></a><div class="content"><a class="title" href="/post/a9a6fba5.html" title="《斩服少女》:超越边界的反叛与自由">《斩服少女》:超越边界的反叛与自由</a><time datetime="2024-10-02T11:00:11.000Z" title="发表于 2024-10-02 19:00:11">2024-10-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/b252ef8a.html" title="LPC1114:按键控制LED闪烁频率"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66fbcf72f21886ccc0e9e7ab.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LPC1114:按键控制LED闪烁频率"></a><div class="content"><a class="title" href="/post/b252ef8a.html" title="LPC1114:按键控制LED闪烁频率">LPC1114:按键控制LED闪烁频率</a><time datetime="2024-10-01T10:39:28.000Z" title="发表于 2024-10-01 18:39:28">2024-10-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/f5610288.html" title="LPC1114:定时器实现呼吸灯"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66fbcf71f21886ccc0e9e6fe.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LPC1114:定时器实现呼吸灯"></a><div class="content"><a class="title" href="/post/f5610288.html" title="LPC1114:定时器实现呼吸灯">LPC1114:定时器实现呼吸灯</a><time datetime="2024-10-01T10:33:10.000Z" title="发表于 2024-10-01 18:33:10">2024-10-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/bd654518.html" title="LPC1114:闪烁的LED"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66fbcf71f21886ccc0e9e6b1.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LPC1114:闪烁的LED"></a><div class="content"><a class="title" href="/post/bd654518.html" title="LPC1114:闪烁的LED">LPC1114:闪烁的LED</a><time datetime="2024-10-01T10:11:37.000Z" title="发表于 2024-10-01 18:11:37">2024-10-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 <i id="heartbeat" class="fa fas fa-heartbeat"></i> 梦如烟</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight,500)"><i class="fas fa-arrow-down"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://moonruyancoments.vercel.app/',
      region: 'ap-guangzhou',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://moonruyancoments.vercel.app/',
      region: 'ap-guangzhou',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))

    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(init,0)
    else getScript('https://cdn.jsdelivr.net/npm/twikoo@1.6.31/dist/twikoo.all.min.js').then(init)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><script>(()=>{
  const loadLivere = () => {
    if (typeof LivereTower === 'object') window.LivereTower.init()
    else {
      (function(d, s) {
          var j, e = d.getElementsByTagName(s)[0];
          if (typeof LivereTower === 'function') { return; }
          j = d.createElement(s);
          j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
          j.async = true;
          e.parentNode.insertBefore(j, e);
      })(document, 'script');
    }
  }

  if ('Twikoo' === 'Livere' || !false) {
    if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
    else loadLivere()
  } else {
    window.loadOtherComment = loadLivere
  }
})()</script></div><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script async src="https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.14/vue.min.js"></script><script async src="https://cdnjs.cloudflare.com/ajax/libs/element-ui/2.15.6/index.js"></script><script src="/live2d-widget/autoload.js"></script><script async src="/js/copy.js"></script><script defer src="/js/cursor.js"></script><script defer src="/js/cat.js"></script><script defer type="text/javascript" src="https://cdn.jsdelivr.net/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script defer src="/js/lunar.js"></script><script defer src="/js/day.js"></script><script async src="/js/title.js"></script><script async src="/js/custom.js"></script><canvas id="snow"></canvas><script async src="/js/snow.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script charset="UTF-8" id="LA_COLLECT" src="https://sdk.51.la/js-sdk-pro.min.js"></script><script src="https://sdk.51.la/perf/js-sdk-perf.min.js" crossorigin="anonymous"></script><script>LA.init({id:"3J4ZDKUTrB9JPpeO",ck:"3J4ZDKUTrB9JPpeO"})</script><script>(new LingQue.Monitor).init({id:"3J4hgU88UZ2zzfMS",sendSuspicious:!0})</script><script async data-pjax src="/js/txmap.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/shuoshuo/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><script data-pjax>var parent,child;document.getElementById("recent-posts")&&"/"===location.pathname&&(parent=document.getElementById("recent-posts"),child='<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://moonruyan.github.io/categories/小说/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📖 梦如烟の原创小说 (18)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://moonruyan.github.io/categories/学习笔记/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📓 梦如烟の学习笔记 (8)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://moonruyan.github.io/categories/教程/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 梦如烟の教程 (4)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://moonruyan.github.io/categories/书摘/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📝 梦如烟の书摘 (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://moonruyan.github.io/categories/杂谈/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📰 梦如烟の杂谈 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://moonruyan.github.io/categories/更新日志/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🆙 梦如烟の博客更新日志 (8)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://moonruyan.github.io/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>',console.log("已挂载magnet"),parent.insertAdjacentHTML("afterbegin",child))</script><style>#catalog_magnet{flex-wrap:wrap;display:flex;width:100%;justify-content:space-between;padding:10px 10px 0 10px;align-content:flex-start}.magnet_item{flex-basis:calc(33.333333333333336% - 5px);background:#f2f2f2;margin-bottom:10px;border-radius:8px;transition:all .2s ease-in-out}.magnet_item:hover{background:#4fb0ea}.magnet_link_more{color:#555}.magnet_link{color:#000}.magnet_link:hover{color:#fff}@media screen and (max-width:600px){.magnet_item{flex-basis:100%}}.magnet_link_context{display:flex;padding:10px;font-size:16px;transition:all .2s ease-in-out}.magnet_link_context:hover{padding:10px 20px}</style><style></style><script data-pjax>function butterfly_swiper_injector_config(){var l=document.getElementById("recent-posts");console.log("已挂载butterfly_swiper"),l.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/77bface8.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66a5a151d9c307b7e9463606.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-19</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/77bface8.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt="">两个人的宇宙</a><div class="blog-slider__text">晚安，不平凡的你。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/77bface8.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/10ad12c6.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66d44683d9c307b7e973f3e9.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-09-01</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/10ad12c6.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt="">瞳人语</a><div class="blog-slider__text">茫茫人海中。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/10ad12c6.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/4d52f91b.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66ab3cb8d9c307b7e91af2f6.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-01</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/4d52f91b.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt="">贫民之墙</a><div class="blog-slider__text">墙内，墙外。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/4d52f91b.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/b5a97844.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66c5ca30d9c307b7e950f8a5.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-21</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/b5a97844.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt="">女巫之心</a><div class="blog-slider__text">真相从不是轻易得来的。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/b5a97844.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/c0ca97ed.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66a5a301d9c307b7e9475d63.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/c0ca97ed.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt="">我从地狱来</a><div class="blog-slider__text">记忆是自我的根基。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/c0ca97ed.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/f2556242.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66a5a151d9c307b7e94635c1.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/f2556242.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt="">界限</a><div class="blog-slider__text">游荡在群星间追寻自我身份的少年。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/f2556242.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/d42fcdae.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66e0fd33d9c307b7e94a9f54.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-09-11</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/d42fcdae.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt="">寻道者</a><div class="blog-slider__text">朝问道。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/d42fcdae.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/1bd7378e.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66af5bd7d9c307b7e99587fd.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/1bd7378e.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt="">漫夜终有星</a><div class="blog-slider__text">黑石改变了一切。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/1bd7378e.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/c0f8c79a.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66937f1cd9c307b7e97cf9a7.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/c0f8c79a.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt="">幻花未开</a><div class="blog-slider__text">花开人未在。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/c0f8c79a.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/7d4db862.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66a5a25ad9c307b7e946e90a.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/7d4db862.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt="">女巫与猫</a><div class="blog-slider__text">少女与猫。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/7d4db862.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>')}for(var elist="undefined".split(","),cpage=location.pathname,epage="/",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_swiper_injector_config()</script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><div class="js-pjax"><script async>for(var arr=document.getElementsByClassName("recent-post-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration","2s"),arr[i].setAttribute("data-wow-delay","200ms"),arr[i].setAttribute("data-wow-offset","30"),arr[i].setAttribute("data-wow-iteration","1")</script><script async>for(var arr=document.getElementsByClassName("card-widget"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration","2s"),arr[i].setAttribute("data-wow-delay","200ms"),arr[i].setAttribute("data-wow-offset","30"),arr[i].setAttribute("data-wow-iteration","1")</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script></body></html>